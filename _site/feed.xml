<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-07-21T11:38:01+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Steve.liu</title><subtitle>A blog of an iOS R&amp;D engineer</subtitle><entry><title type="html">&amp;lt;font color=#0099ff&amp;gt;SDK自动打包&amp;lt;/font&amp;gt;</title><link href="http://localhost:4000/SDKAutoArchive/" rel="alternate" type="text/html" title="&amp;lt;font color=#0099ff&amp;gt;SDK自动打包&amp;lt;/font&amp;gt;" /><published>2017-08-08T00:00:00+08:00</published><updated>2017-08-08T00:00:00+08:00</updated><id>http://localhost:4000/SDKAutoArchive</id><content type="html" xml:base="http://localhost:4000/SDKAutoArchive/">&lt;p&gt;背景：
由于iOS Framework打包出来是分CPU指令集的，所以需要每个CPU指令集都打包一个Framework，然后使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lipo -create&lt;/code&gt;命令将所有CPU指令集合并，才能形成一个兼容所有设备和模拟器的Framework。这样的打包流程复杂而繁琐，对于需要经常打包测试的需求来说明显是不合适的。&lt;/p&gt;

&lt;h3 id=&quot;解决方案&quot;&gt;解决方案&lt;/h3&gt;
&lt;p&gt;使用xcode &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Aggregate&lt;/code&gt;工具中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Run Script&lt;/code&gt;自动进行不同CPU指令集打包，并自动合并所有CPU指令集&lt;/p&gt;

&lt;h3 id=&quot;处理器指令集介绍&quot;&gt;处理器指令集介绍&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;ARM处理器
	- armv7
	- armv7s
 	- arm64&lt;/li&gt;
  &lt;li&gt;Mac处理器
    &lt;ul&gt;
      &lt;li&gt;i386&lt;/li&gt;
      &lt;li&gt;x86_64&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;指令集&lt;/th&gt;
      &lt;th&gt;设备&lt;/th&gt;
      &lt;th&gt;支持设备&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;arm64&lt;/td&gt;
      &lt;td&gt;真机64位&lt;/td&gt;
      &lt;td&gt;iPhone6s、iphone6s plus、iPhone6、iPhone6 plus、iPhone5S、iPad Air、 iPad mini2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;armv7s&lt;/td&gt;
      &lt;td&gt;真机32位&lt;/td&gt;
      &lt;td&gt;iPhone5、iPhone5C、iPad4(iPad with Retina Display)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;armv7&lt;/td&gt;
      &lt;td&gt;真机32位&lt;/td&gt;
      &lt;td&gt;iPhone4、iPhone4S、iPad、iPad2、iPad3(The New iPad)、iPad mini、iPod Touch 3G、iPod Touch4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;i386&lt;/td&gt;
      &lt;td&gt;模拟器32位&lt;/td&gt;
      &lt;td&gt;针对intel通用微处理器32位处理器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;x86_64&lt;/td&gt;
      &lt;td&gt;模拟器64位&lt;/td&gt;
      &lt;td&gt;针对x86架构的64位处理器&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;添加-aggregate&quot;&gt;添加 Aggregate&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;使用Xcode打开打包工程&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;File&lt;/code&gt;→&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;New&lt;/code&gt;→&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Target&lt;/code&gt;→&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cross-platform&lt;/code&gt;→&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Aggregate&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;命名为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AvidlyAdsSDKArchive&lt;/code&gt;(自由命名)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;添加-run-script&quot;&gt;添加 Run Script&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;打开&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AvidlyAdsSDKArchive&lt;/code&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Aggregate &lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BuildPhases&lt;/code&gt;→&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;New&lt;/code&gt;→&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt;→&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cross-platform&lt;/code&gt;→&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;New Run Script Phase&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;打开新建的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Run Script&lt;/code&gt;，在shell中键入打包代码&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;shell编写打包代码&quot;&gt;shell编写打包代码&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 工程名称
# 如果工程名称和Framework的Target名称不一样的 话，要自定义FMKNAME
# 例如: FMK_NAME = &quot;MyFramework&quot;
FMK_NAME=${PROJECT_NAME}

# 工程Info.list路径
InfoPlist=${SRCROOT}/${PROJECT_NAME}/Info.plist

# 工程Version
Version=$(/usr/libexec/PlistBuddy -c &quot;Print CFBundleShortVersionString&quot; $InfoPlist)
Version=${Version//./}

# 工程Build
Build=$(/usr/libexec/PlistBuddy -c &quot;Print CFBundleVersion&quot; $InfoPlist)

# SDK文件夹名称
SDKFilePath=${SRCROOT}/${PROJECT_NAME}_${Version}_${Build}

# 文件路径是否存在
if [ -d &quot;${SDKFilePath}&quot; ]
then
rm -rf &quot;${SDKFilePath}&quot;
fi
mkdir -p &quot;${SDKFilePath}&quot;

# 当前时间
updataDate=`date +%F`

# 将信息写入文件
updataFileName=${SDKFilePath}/version.md
touch ${updataFileName}
echo 版本:${Version} &amp;gt;&amp;gt; ${updataFileName}
echo 编译:${Build} &amp;gt;&amp;gt; ${updataFileName}
echo 时间:${updataDate} &amp;gt;&amp;gt; ${updataFileName}
echo 更新: &amp;gt;&amp;gt; ${updataFileName}

# SDK目录
INSTALL_DIR=${SDKFilePath}/${FMK_NAME}.framework

# Working dir will be deleted after the framework creation.
WRK_DIR=build
DEVICE_DIR=${WRK_DIR}/Release-iphoneos/${FMK_NAME}.framework
SIMULATOR_DIR=${WRK_DIR}/Release-iphonesimulator/${FMK_NAME}.framework

# -configuration ${CONFIGURATION}
# Clean and Building both architectures.
xcodebuild -configuration &quot;Release&quot; -target &quot;${FMK_NAME}&quot; -sdk iphoneos clean build
xcodebuild -configuration &quot;Release&quot; -target &quot;${FMK_NAME}&quot; -sdk iphonesimulator clean build

# Cleaning the oldest.
if [ -d &quot;${INSTALL_DIR}&quot; ]
then
rm -rf &quot;${INSTALL_DIR}&quot;
fi
mkdir -p &quot;${INSTALL_DIR}&quot;
cp -R &quot;${DEVICE_DIR}/&quot; &quot;${INSTALL_DIR}/&quot;

# Uses the Lipo Tool to merge both binary files (i386 + armv6/armv7) into one Universal final product.
lipo -create &quot;${DEVICE_DIR}/${FMK_NAME}&quot; &quot;${SIMULATOR_DIR}/${FMK_NAME}&quot; -output &quot;${INSTALL_DIR}/${FMK_NAME}&quot;
rm -r &quot;${WRK_DIR}&quot;
open &quot;${SRCROOT}&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="SDK" /><category term="Framework" /><summary type="html">背景： 由于iOS Framework打包出来是分CPU指令集的，所以需要每个CPU指令集都打包一个Framework，然后使用lipo -create命令将所有CPU指令集合并，才能形成一个兼容所有设备和模拟器的Framework。这样的打包流程复杂而繁琐，对于需要经常打包测试的需求来说明显是不合适的。 解决方案 使用xcode Aggregate工具中的Run Script自动进行不同CPU指令集打包，并自动合并所有CPU指令集 处理器指令集介绍 ARM处理器 - armv7 - armv7s - arm64 Mac处理器 i386 x86_64 指令集 设备 支持设备</summary></entry><entry><title type="html">&amp;lt;font color=#0099ff&amp;gt;CocoaPods托管Framework&amp;lt;/font&amp;gt;</title><link href="http://localhost:4000/CocoaPodsHostingFramework/" rel="alternate" type="text/html" title="&amp;lt;font color=#0099ff&amp;gt;CocoaPods托管Framework&amp;lt;/font&amp;gt;" /><published>2017-06-16T00:00:00+08:00</published><updated>2017-06-16T00:00:00+08:00</updated><id>http://localhost:4000/CocoaPodsHostingFramework</id><content type="html" xml:base="http://localhost:4000/CocoaPodsHostingFramework/">&lt;p&gt;在发布sdk中，需要在CocoaPods上托管Framework&lt;/p&gt;

&lt;h3 id=&quot;安装cocoapods&quot;&gt;安装CocoaPods&lt;/h3&gt;

&lt;p&gt;首先安装CocoaPods，没安装的自行安装&lt;/p&gt;

&lt;h3 id=&quot;处理源码&quot;&gt;处理源码&lt;/h3&gt;
&lt;p&gt;第一步在github上创建源码库（我们的源码是Framework），并把源码push到github上&lt;/p&gt;

&lt;p&gt;github地址：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://github.com/guojunliu/AvidlyAdsSDK.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;podspec文件&quot;&gt;podspec文件&lt;/h3&gt;
&lt;p&gt;第二步,在目录下创建&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.podspec&lt;/code&gt;文件，此处创建的是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AvidlyAdsSDK.podspec&lt;/code&gt;，&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ pod spec create AvidlyAdsSDK
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;用编辑器打开.podspec文件 (我自己用Sublime Text)&lt;/p&gt;

&lt;p&gt;文件内容为&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Pod::Spec.new do |s|
  s.name             = 'AvidlyAdsSDK'
  s.version          = '2.0.20'
  s.summary          = 'Avidly Ad SDK'
  s.description      = &amp;lt;&amp;lt;-DESC
Avidly Ad SDK.
                       DESC

  s.homepage         = 'http://ads-sdk-doc.haloapps.com/docs/show/2'
  s.license          = { :type =&amp;gt; 'MIT', :file =&amp;gt; 'LICENSE' }
  s.author           = { &quot;steve&quot; =&amp;gt; &quot;steve.liu@holaverse.com&quot; }
  s.source           = { :git =&amp;gt; 'https://github.com/guojunliu/AvidlyAdsSDK.git', :tag =&amp;gt; s.version }

  s.ios.deployment_target = '8.0'

  s.source_files = 'Framework/Appnext/include/*', 'Framework/Chance/include/*', 'Framework/Domob/include/*'
  
  s.resources = &quot;Framework/Chance/resource/*&quot;, &quot;Framework/Domob/resource/*&quot;, &quot;Framework/Vungle/resource/*&quot;, &quot;Framework/AvidlyAdsSDK/resource/*&quot;,

  s.public_header_files = 'Framework/Appnext/include/*', 'Framework/Chance/include/*', 'Framework/Domob/include/*'

  s.library = 'sqlite3', 'z'

  s.frameworks = 'QuartzCore', 'MediaPlayer', 'CoreMedia', 'CoreGraphics', 'CFNetwork', 'WebKit', 'WatchConnectivity', 'SystemConfiguration', 'StoreKit', 'Social', 'MessageUI','JavaScriptCore','EventKit','CoreTelephony','AVFoundation','AudioToolbox','AdSupport'

  s.vendored_libraries = &quot;Framework/Appnext/libAppnextLib.a&quot;, &quot;Framework/Appnext/libAppnextSDKCore.a&quot;, &quot;Framework/Chance/libChanceAd_Video.a&quot;, &quot;Framework/Domob/libIndependentVideoSDK.a&quot;

  s.vendored_frameworks = 'Framework/AdColony/AdColony.framework', 'Framework/Mobvista/MVSDK.framework', 'Framework/Mobvista/MVSDKReward.framework', 'Framework/Unity/UnityAds.framework', 'Framework/Vungle/VungleSDK.framework', 'Framework/AvidlyAdsSDK/AvidlyAdsSDK.framework', 'Framework/FBAudienceNetwork/FBAudienceNetwork.framework', 'Framework/GoogleMobileAds/GoogleMobileAds.framework', 'Framework/HolaStatisticalSDK/HolaStatisticalSDK.framework', 'Framework/OneWay/OneWaySDK.framework'
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;字段解释&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;字段&lt;/th&gt;
      &lt;th&gt;解释&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;name&lt;/td&gt;
      &lt;td&gt;名称&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;version&lt;/td&gt;
      &lt;td&gt;版本号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;summary&lt;/td&gt;
      &lt;td&gt;摘要&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;description&lt;/td&gt;
      &lt;td&gt;描述&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;homepage&lt;/td&gt;
      &lt;td&gt;主页&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;license&lt;/td&gt;
      &lt;td&gt;许可证，这个必须要有，且按照上述格式，否则会出错&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;author&lt;/td&gt;
      &lt;td&gt;作者&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;source&lt;/td&gt;
      &lt;td&gt;资源，源码git库&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ios.deployment_target&lt;/td&gt;
      &lt;td&gt;ios 编译版本&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;source_files&lt;/td&gt;
      &lt;td&gt;源文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;resources&lt;/td&gt;
      &lt;td&gt;资源包，比如图片，bundle等&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;public_header_files&lt;/td&gt;
      &lt;td&gt;共用头文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;library&lt;/td&gt;
      &lt;td&gt;依赖的系统tbd库，要去掉&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lib&lt;/code&gt;前缀,例如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libsqlite3.tbd&lt;/code&gt;要写成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sqlite3&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;frameworks&lt;/td&gt;
      &lt;td&gt;依赖的系统Framework&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;vendored_libraries&lt;/td&gt;
      &lt;td&gt;非系统库，如依赖的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.a&lt;/code&gt;第三方静态库。需要按照目录写&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;vendored_frameworks&lt;/td&gt;
      &lt;td&gt;非系统库，如依赖的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.framework&lt;/code&gt;第三方静态库，我们此次托管的是framework，所以也写在这里。需要按照目录写&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;编写完之后需要校验下&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;podspec&lt;/code&gt;文件格式是的正确，Xcode是否能正常编译。使用下面代码&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ pod lib lint
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;出现下面代码表示验证通过&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-&amp;gt; AvidlyAdsSDK (2.0.20)

AvidlyAdsSDK passed validation.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接下来连同&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;podspec文件&lt;/code&gt;一起push到github，由于Cocoapods在自己配置的s.source git中是以版本号检索的，即git的tag，所以我们push之后，别忘记给当次commit打上tag标签，这里打的是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2.0.20&lt;/code&gt;,要和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;podspec文件&lt;/code&gt;中一致，才能被检索到&lt;/p&gt;

&lt;h3 id=&quot;推送到官方库&quot;&gt;推送到官方库&lt;/h3&gt;
&lt;p&gt;最后是使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pod trunk&lt;/code&gt;命令，把podspec文件推送到CocoaPod官方库&lt;/p&gt;

&lt;p&gt;pod trunk 需要注册 具体做法这里不再赘述 请移步CocoaPod官网&lt;/p&gt;

&lt;p&gt;pod trunk 设置完毕后执行命令&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ pod trunk push AvidlyAdsSDK.podspec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因为我们依赖的SDK比较多，源码比较大，所以整个过程比较耗时。&lt;/p&gt;

&lt;p&gt;推送完成之后查询一下&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pod search AvidlyAdsSDK
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可以看到已经能查询到我们推送到CocoaPod官方的库了&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-&amp;gt; AvidlyAdsSDK (2.0.20)
   Avidly Ad SDK
   pod 'AvidlyAdsSDK', '~&amp;gt; 2.0.20'
   - Homepage: http://ads-sdk-doc.haloapps.com/docs/show/2
   - Source:   https://github.com/guojunliu/AvidlyAdsSDK.git
   - Versions: 2.0.20, 2.0.19 [AvidlyAdsSDK repo]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;search不到&quot;&gt;search不到？&lt;/h3&gt;

&lt;p&gt;上一步中，在推送到官方库之后，有可能在search的时候，search不到，出现下面的提示&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[!] Unable to find a pod with name, author, summary, or description matching `AvidlyAdsSDK`
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;虽然我们push到官方可了，但是依然search不到&lt;/p&gt;

&lt;p&gt;要解决这个问题，首先我们要了解下cocoapods的机制，在安装cocoapods的时候，使用过下面的命令&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pod setup
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这行命令其中最重要的作用就是将cocoapods官方repo，clone到我们本地。&lt;/p&gt;

&lt;p&gt;我们可以看下我们本地的repo&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pod repo list
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;master
- Type: git (master)
- URL:  https://github.com/CocoaPods/Specs.git
- Path: /Users/steve/.cocoapods/repos/master

1 repo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到我们本地目前只有一个repo，就是官方的master repo&lt;/p&gt;

&lt;p&gt;这个master repo中包含了所有push到cocoapod的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;podspec文件&lt;/code&gt;，可以去本机cocoapods目录下看一下，有成千上万的podspec文件。&lt;/p&gt;

&lt;p&gt;解决上述问题的最简单办法就是重新调用下&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pod setup&lt;/code&gt;，重新clone下master repo&lt;/p&gt;

&lt;h4 id=&quot;但是&quot;&gt;但是&lt;/h4&gt;

&lt;p&gt;由于master repo实在太大（大概700M+），我们不希望CP浪费时间在clone repo上，为了提高效率，所以我们要使用我们自己的私有repo&lt;/p&gt;

&lt;h3 id=&quot;私有库&quot;&gt;私有库&lt;/h3&gt;

&lt;p&gt;先来说一个概念，什么是repo？它是所有的Pods的一个索引，就是一个容器，所有公开的Pods都在这个里面，它实际是一个Git仓库remote端在GitHub上，但是当你使用了Cocoapods后它会被clone到本地的~/.cocoapods/repos目录下。可以进入到这个目录看到master文件夹就是这个官方的repo了。这个master目录的结构是这个样子的&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;master/xxx库/0.0.1版本/xxx.podspec
            /0.0.2版本/xxx.podspec
master/zzz库/2.0.1版本/zzz.podspec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;master&lt;/code&gt;是repo名称，下一级目录&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xxx库&lt;/code&gt;是你托管的库名称，再下一级&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0.0.1版本&lt;/code&gt;是你库的版本，再下一级&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xxx.podspec&lt;/code&gt;就是你自己的podspec&lt;/p&gt;

&lt;p&gt;所以我们模拟这个目录创建一个就好了&lt;/p&gt;

&lt;p&gt;首先创建一个git库，这里是&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://github.com/guojunliu/AvidlyAdsSDK-SpecsRepo.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接下来在创建目录及文件&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AvidlyAdsSDK/2.0.20/AvidlyAdsSDK.podspec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果需要维护多个版本的线上包，那就&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AvidlyAdsSDK/2.0.19/AvidlyAdsSDK.podspec
            /2.0.20/AvidlyAdsSDK.podspec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接下来push到github上&lt;/p&gt;

&lt;p&gt;repo创建完了，接下来我们将repo clone到我们本地，先看下我们本地的repo&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pod repo list
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;master
- Type: git (master)
- URL:  https://github.com/CocoaPods/Specs.git
- Path: /Users/steve/.cocoapods/repos/master

1 repo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;只有master&lt;/p&gt;

&lt;p&gt;接下来colen我们自己的repo&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pod repo add Avidly https://github.com/guojunliu/AvidlyAdsSDK-SpecsRepo.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Avidly&lt;/code&gt;是我们repo clone到本地的名字，自己命名&lt;/p&gt;

&lt;p&gt;完成之后再来看下本地的repo&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Avidly
- Type: git (master)
- URL:  https://github.com/guojunliu/AvidlyAdsSDK-SpecsRepo.git
- Path: /Users/steve/.cocoapods/repos/Avidly

master
- Type: git (master)
- URL:  https://github.com/CocoaPods/Specs.git
- Path: /Users/steve/.cocoapods/repos/master

2 repos
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;已经存在了，可以去~/.cocoapods/repos目录下瞅瞅&lt;/p&gt;

&lt;p&gt;接下来再search就可以找到我们托管的Framework了&lt;/p&gt;

&lt;p&gt;这样我们就不用让CP再等待setup了&lt;/p&gt;

&lt;h3 id=&quot;测试&quot;&gt;测试&lt;/h3&gt;

&lt;p&gt;Podfile如下&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;platform :ios, '8.0'
use_frameworks!

target ‘testAvidlyPod’ do
  source 'https://github.com/guojunliu/AvidlyAdsSDK-SpecsRepo.git'
  pod 'AvidlyAdsSDK', '~&amp;gt; 2.0.20'
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中source就是我们自己的私有库&lt;/p&gt;

&lt;h3 id=&quot;可能会遇到的问题&quot;&gt;可能会遇到的问题&lt;/h3&gt;

&lt;p&gt;1、swift验证不过&lt;/p&gt;

&lt;p&gt;2、xcode编译不过导致验证不过&lt;/p&gt;

&lt;p&gt;3、clone出错&lt;/p&gt;

&lt;p&gt;4、xcworkspace编译不过&lt;/p&gt;</content><author><name></name></author><category term="SDK" /><category term="Framework" /><summary type="html">在发布sdk中，需要在CocoaPods上托管Framework 安装CocoaPods 首先安装CocoaPods，没安装的自行安装 处理源码 第一步在github上创建源码库（我们的源码是Framework），并把源码push到github上 github地址： https://github.com/guojunliu/AvidlyAdsSDK.git podspec文件 第二步,在目录下创建.podspec文件，此处创建的是AvidlyAdsSDK.podspec， $ pod spec create AvidlyAdsSDK 用编辑器打开.podspec文件 (我自己用Sublime Text) 文件内容为 Pod::Spec.new do |s| s.name = 'AvidlyAdsSDK' s.version = '2.0.20' s.summary = 'Avidly Ad SDK' s.description = &amp;lt;&amp;lt;-DESC Avidly Ad SDK. DESC s.homepage = 'http://ads-sdk-doc.haloapps.com/docs/show/2' s.license = { :type =&amp;gt; 'MIT', :file =&amp;gt; 'LICENSE' } s.author = { &quot;steve&quot; =&amp;gt; &quot;steve.liu@holaverse.com&quot; } s.source = { :git =&amp;gt; 'https://github.com/guojunliu/AvidlyAdsSDK.git', :tag =&amp;gt; s.version } s.ios.deployment_target = '8.0' s.source_files = 'Framework/Appnext/include/*', 'Framework/Chance/include/*', 'Framework/Domob/include/*' s.resources = &quot;Framework/Chance/resource/*&quot;, &quot;Framework/Domob/resource/*&quot;, &quot;Framework/Vungle/resource/*&quot;, &quot;Framework/AvidlyAdsSDK/resource/*&quot;, s.public_header_files = 'Framework/Appnext/include/*', 'Framework/Chance/include/*', 'Framework/Domob/include/*' s.library = 'sqlite3', 'z' s.frameworks = 'QuartzCore', 'MediaPlayer', 'CoreMedia', 'CoreGraphics', 'CFNetwork', 'WebKit', 'WatchConnectivity', 'SystemConfiguration', 'StoreKit', 'Social', 'MessageUI','JavaScriptCore','EventKit','CoreTelephony','AVFoundation','AudioToolbox','AdSupport' s.vendored_libraries = &quot;Framework/Appnext/libAppnextLib.a&quot;, &quot;Framework/Appnext/libAppnextSDKCore.a&quot;, &quot;Framework/Chance/libChanceAd_Video.a&quot;, &quot;Framework/Domob/libIndependentVideoSDK.a&quot; s.vendored_frameworks = 'Framework/AdColony/AdColony.framework', 'Framework/Mobvista/MVSDK.framework', 'Framework/Mobvista/MVSDKReward.framework', 'Framework/Unity/UnityAds.framework', 'Framework/Vungle/VungleSDK.framework', 'Framework/AvidlyAdsSDK/AvidlyAdsSDK.framework', 'Framework/FBAudienceNetwork/FBAudienceNetwork.framework', 'Framework/GoogleMobileAds/GoogleMobileAds.framework', 'Framework/HolaStatisticalSDK/HolaStatisticalSDK.framework', 'Framework/OneWay/OneWaySDK.framework' end 字段解释 字段 解释</summary></entry><entry><title type="html">&amp;lt;font color=#0099ff&amp;gt;djinni中文文档&amp;lt;/font&amp;gt;</title><link href="http://localhost:4000/djinni/" rel="alternate" type="text/html" title="&amp;lt;font color=#0099ff&amp;gt;djinni中文文档&amp;lt;/font&amp;gt;" /><published>2016-10-28T00:00:00+08:00</published><updated>2016-10-28T00:00:00+08:00</updated><id>http://localhost:4000/djinni</id><content type="html" xml:base="http://localhost:4000/djinni/">&lt;p&gt;Djinni 是一个用来生成跨语言的类型声明和接口绑定的工具，主要用于 C++ 和 Java 以及 Objective-C 间的互通。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;好处：&lt;/li&gt;
  &lt;li&gt;用了接口描述文件。声明清晰、修改简易，并保证了跨平台接口的一致性。&lt;/li&gt;
  &lt;li&gt;自动生成接口绑定代码。免去了绑定 C++ 和 Java (JNI) 及 Objective-C (Objective-C++) 的麻烦。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1-配置djinni&quot;&gt;1 配置djinni&lt;/h2&gt;

&lt;h3 id=&quot;11-下载djinni&quot;&gt;1.1 下载djinni&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://github.com/dropbox/djinni.git 将下载好的djinni放在[example_root]/deps/ 下
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此时目录结构为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/djinni/1.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;12-编译djinni&quot;&gt;1.2 编译djinni&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd [djinni_root]/
$ src/build
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;../images/djinni/2.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第一次编译的时候会去下载sbt配置&lt;/p&gt;

&lt;p&gt;本人系统环境是macOS Sierra 10.12 , 在此环境下sbt下载失败，导致编译失败&lt;/p&gt;

&lt;p&gt;如果sbt下载失败的话，项目中放置了一个sbt的压缩包（里边文件默认隐藏的），复制里边的文件到你的用户文件夹下就可以了&lt;/p&gt;

&lt;h2 id=&quot;2-使用djinni&quot;&gt;2 使用djinni&lt;/h2&gt;

&lt;h3 id=&quot;21-编写djinni格式文件&quot;&gt;2.1 编写djinni格式文件&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hello_world = interface +c {
	static create():hello_world;
	get_hello_world(): string;
	get_name(): string;
	set_name(name:string);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;命名为helloworld.djinni 并放置在[example_root]/ 下&lt;/p&gt;

&lt;h3 id=&quot;22-编写shell文件&quot;&gt;2.2 编写shell文件&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#! /usr/bin/env bash
 
base_dir=$(cd &quot;`dirname &quot;0&quot;`&quot; &amp;amp;&amp;amp; pwd)
cpp_out=&quot;$base_dir/generated-src/cpp&quot;
jni_out=&quot;$base_dir/generated-src/jni&quot;
objc_out=&quot;$base_dir/generated-src/objc&quot;
java_out=&quot;$base_dir/generated-src/java/com/mycompany/helloworld&quot;
java_package=&quot;com.mycompany.helloworld&quot;
namespace=&quot;helloworld&quot;
objc_prefix=&quot;HW&quot;
djinni_file=&quot;helloworld.djinni&quot;
 
deps/djinni/src/run \
   		--java-out $java_out \
   		--java-package $java_package \
   		--ident-java-field mFooBar \
   		\
   		--cpp-out $cpp_out \
   		--cpp-namespace $namespace \
   		\
   		--jni-out $jni_out \
   		--ident-jni-class NativeFooBar \
   		--ident-jni-file NativeFooBar \
   		\
   		--objc-out $objc_out \
   		--objc-type-prefix $objc_prefix \
   		\
   		--objcpp-out $objc_out \
   		\
   		--idl $djinni_file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;命名为run_djinni.sh 并放置在[example_root]/ 下&lt;/p&gt;

&lt;p&gt;此时目录结构为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/djinni/3.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;23-生成接口代码&quot;&gt;2.3 生成接口代码&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd [example_root]/  
$ sh ./run_djinni.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;运行成功输出：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/djinni/4.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以及现在目录结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/djinni/5.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里可以看到：依据描述文件helloworld.djinni，在generated-src目录下自动生产了 C++ 和 Java 及 Objective-C 的绑定代码。继续要做的，只是写它们的具体实现&lt;/p&gt;

&lt;h2 id=&quot;3-编写c代码&quot;&gt;3 编写c++代码&lt;/h2&gt;
&lt;h3 id=&quot;31-创建c工程&quot;&gt;3.1 创建c++工程&lt;/h3&gt;
&lt;p&gt;这里用 XCode 创建一个 C++ 工程，来测试 C++ 接口代码。&lt;/p&gt;

&lt;p&gt;首先，打开 XCode ，选择”Create a new Xcode project”。然后，选择”Command Line Tool”，来新建命令行工具。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/djinni/6.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;“Next”到下一步时，”Language”选择”C++”。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/djinni/7.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;“Next”到下一步，放在[example_root]/ 下&lt;/p&gt;

&lt;p&gt;此时目录结构为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/djinni/8.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;32-编写c实现代码&quot;&gt;3.2 编写c++实现代码&lt;/h3&gt;

&lt;p&gt;首先在[example_root]/ 下创建src/cpp目录，用来存放c++实现代码&lt;/p&gt;

&lt;p&gt;src/cpp/hello_world_impl.hpp:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#pragma once
 
#include &quot;hello_world.hpp&quot;
 
namespace helloworld {

	class HelloWorldImpl : public helloworld::HelloWorld {
    
	public:
    
    	// Constructor
    	HelloWorldImpl();
    
    	// Our method that returns a string
    	std::string get_hello_world();
    
	};

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;src/cpp/hello_world_impl.cpp:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &quot;hello_world_impl.hpp&quot;
#include &amp;lt;string&amp;gt;
 
namespace helloworld {

	std::shared_ptr&amp;lt;HelloWorld&amp;gt; HelloWorld::create() {
	    return std::make_shared&amp;lt;HelloWorldImpl&amp;gt;();
	}
	
	HelloWorldImpl::HelloWorldImpl() {
 	
	}

	std::string HelloWorldImpl::get_hello_world() {
    
 	   std::string myString = &quot;Hello World! &quot;;
    
   	 time_t t = time(0);
   	 tm now=*localtime(&amp;amp;t);
    	char tmdescr[200]={0};
    	const char fmt[]=&quot;%r&quot;;
    	if (strftime(tmdescr, sizeof(tmdescr)-1, fmt, &amp;amp;now)&amp;gt;0) {
    	    myString += tmdescr;
    	}
    
    	return myString;
    
	}

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此时目录结构为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/djinni/9.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;33-调试c代码&quot;&gt;3.3 调试c++代码&lt;/h3&gt;

&lt;p&gt;接下来，把以下 C++ 接口代码文件，拖动到 Xcode 工程目录来引入(只需引用文件，避免复制。)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;generated-src/cpp/hello_world.hpp
src/cpp/hello_world_impl.cpp
src/cpp/hello_world_impl.hpp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此时目录结构为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/djinni/10.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;编写以下代码：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

#include &quot;hello_world_impl.hpp&quot;

int main(int argc, const char * argv[]) {

	helloworld::HelloWorldImpl hw = helloworld::HelloWorldImpl();

	string myString = hw.get_hello_world();
	cout &amp;lt;&amp;lt; myString &amp;lt;&amp;lt; endl;

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出为:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hello World! 02:28:10 PM
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;c++代码调试通过&lt;/p&gt;

&lt;h2 id=&quot;4-ios工程&quot;&gt;4 iOS工程&lt;/h2&gt;
&lt;h3 id=&quot;41-创建ios工程&quot;&gt;4.1 创建ios工程&lt;/h3&gt;

&lt;p&gt;在[example_root]/ 下创建ios_project目录&lt;/p&gt;

&lt;p&gt;Xcode创建ios工程，命名为HelloWorld&lt;/p&gt;

&lt;h3 id=&quot;42-添加文件&quot;&gt;4.2 添加文件&lt;/h3&gt;
&lt;p&gt;将以下目录中文件加入Xcode（只引用不copy），并虚拟目录分组为oc，c++，djinni&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[example_root]/generated-src/objc/
[example_root]/generated-src/cpp/
[example_root]/scr/cpp/
[example_root]/deps/djinni/support-lib/objc/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此时目录结构为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/djinni/11.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中&lt;/p&gt;

&lt;p&gt;oc文件夹中为djinni生成的接口文件
c++文件夹中为djinni生成的接口文件和我们自己写的c++实现文件
djinni文件夹中为转换文件（拖入工程就可以了）&lt;/p&gt;

&lt;h2 id=&quot;43-调试&quot;&gt;4.3 调试&lt;/h2&gt;

&lt;p&gt;此时我们调用c++写的实现代码，只需要调用我们oc文件夹中的接口文件啦&lt;/p&gt;

&lt;p&gt;首先引入头文件&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &quot;HWHelloWorld.h&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接着调用代码&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSString *str = [[HWHelloWorld create] getHelloWorld];
NSLog(@&quot;str:%@&quot;,str);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hello World! 02:28:10 PM
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;perfect ！！！&lt;/p&gt;

&lt;h2 id=&quot;问答&quot;&gt;问答&lt;/h2&gt;
&lt;p&gt;Q：oc可以和c++混编为objective-c++，那么我们直接oc和c++互相调用不就行了吗，为什么还要用djinni呢？&lt;/p&gt;

&lt;p&gt;A：oc可以和c++混编，但是java是需要通过jni。所以使用djinni就是为了统一接口，让同一份c++代码可以被oc和java调用，让c++工程师、objective-c工程师、java工程师能够愉快的一起合作项目。ps：如果只是单纯的想在oc里边混编c++，可以完全不用djinni&lt;/p&gt;

&lt;p&gt;Q：上边的例子中，是c++写实现代码，java和oc调用，那么有没有oc和java写实现代码，c++调用呢？&lt;/p&gt;

&lt;p&gt;A：提出这个问题，说明你对c++跨平台有一定的了解了。当然啦，有调用，就有被调用。如果仔细看的上边的例子的话，会发现我们在helloworld.djinni文件中定义接口的时候，我们是这样写的hello_world = interface +c {}，那么这个+c是什么意思的，+c就是c++来实现代码，供其他平台调用。反过来我们可以写 +j +o，意思就是java和oc写实现代码，c++来调用。这样就实现了c++，java，oc之间的互相调用&lt;/p&gt;

&lt;p&gt;Q：djinni与世面上的H5技术跨平台，Xamarin跨平台有什么区别呢？&lt;/p&gt;

&lt;p&gt;A：首先来回答djinni和h5、Xamarin的区别。djinni可以说是由下至上的跨平台，主要用底层逻辑代码的跨平台，而UI则交给iOS和android平台去完成。h5则是由上至下的跨平台，UI统一，底层逻辑需要iOS和android各自平台去实现。而Xamarin则可以说是上下齐发力，底层是c#翻译ios的cocoa Touch框架和android框架，UI用自创的的框架统一ios和android平台的UI。&lt;/p&gt;

&lt;p&gt;优缺点：&lt;/p&gt;

&lt;p&gt;djinni：优点是不依赖于IDE，更底层，速度更快，更稳定。缺点是得会c++。如果公司做游戏的，那么c++大神应该会不少（笔者就是这个情况）&lt;/p&gt;

&lt;p&gt;H5：前几年h5最大的问题，就是性能，渲染太差，这几年好了很多。缺点是很多底层API调用不到，需要各自平台去实现&lt;/p&gt;

&lt;p&gt;Xamarin：笔者有幸研究了大半年的Xamarin，翻译了已经上架的一个APP。优点是统一了语言c#。缺点是收费（现在已经免费了），依赖IDE，要用Xamarin Studio或者VS。对习惯了Xcode的coder可能比较难接受，另外一个缺点，就是ios和android已经有很多成熟的库，而xamarin没有。比如笔者要接一个支付宝支付，然而并没有这样的xamarin库，需要使用者自己去binding。&lt;/p&gt;

&lt;p&gt;最后，这个问题，选你适合的跨平台解决方案。&lt;/p&gt;

&lt;p&gt;问答会持续更新哦 ！！！&lt;/p&gt;

&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;

&lt;p&gt;一个根据djinni写成的demo（ios），解决了macOS Sierra下第一次build时出错的问题&lt;/p&gt;

&lt;p&gt;原文及demo托管在github上 https://github.com/guojunliu/djinni&lt;/p&gt;

&lt;p&gt;如果这篇文章或者demo能帮到你的话，麻烦给个Star，给个星星哦，能让它继续帮到想使用djinni的人&lt;/p&gt;</content><author><name></name></author><category term="c++" /><category term="djinni" /><summary type="html">Djinni 是一个用来生成跨语言的类型声明和接口绑定的工具，主要用于 C++ 和 Java 以及 Objective-C 间的互通。 好处： 用了接口描述文件。声明清晰、修改简易，并保证了跨平台接口的一致性。 自动生成接口绑定代码。免去了绑定 C++ 和 Java (JNI) 及 Objective-C (Objective-C++) 的麻烦。 1 配置djinni 1.1 下载djinni https://github.com/dropbox/djinni.git 将下载好的djinni放在[example_root]/deps/ 下 此时目录结构为： 1.2 编译djinni $ cd [djinni_root]/ $ src/build 第一次编译的时候会去下载sbt配置 本人系统环境是macOS Sierra 10.12 , 在此环境下sbt下载失败，导致编译失败 如果sbt下载失败的话，项目中放置了一个sbt的压缩包（里边文件默认隐藏的），复制里边的文件到你的用户文件夹下就可以了 2 使用djinni 2.1 编写djinni格式文件 hello_world = interface +c { static create():hello_world; get_hello_world(): string; get_name(): string; set_name(name:string); } 命名为helloworld.djinni 并放置在[example_root]/ 下 2.2 编写shell文件 #! /usr/bin/env bash base_dir=$(cd &quot;`dirname &quot;0&quot;`&quot; &amp;amp;&amp;amp; pwd) cpp_out=&quot;$base_dir/generated-src/cpp&quot; jni_out=&quot;$base_dir/generated-src/jni&quot; objc_out=&quot;$base_dir/generated-src/objc&quot; java_out=&quot;$base_dir/generated-src/java/com/mycompany/helloworld&quot; java_package=&quot;com.mycompany.helloworld&quot; namespace=&quot;helloworld&quot; objc_prefix=&quot;HW&quot; djinni_file=&quot;helloworld.djinni&quot; deps/djinni/src/run \ --java-out $java_out \ --java-package $java_package \ --ident-java-field mFooBar \ \ --cpp-out $cpp_out \ --cpp-namespace $namespace \ \ --jni-out $jni_out \ --ident-jni-class NativeFooBar \ --ident-jni-file NativeFooBar \ \ --objc-out $objc_out \ --objc-type-prefix $objc_prefix \ \ --objcpp-out $objc_out \ \ --idl $djinni_file 命名为run_djinni.sh 并放置在[example_root]/ 下 此时目录结构为： 2.3 生成接口代码 $ cd [example_root]/ $ sh ./run_djinni.sh 运行成功输出： 以及现在目录结构： 这里可以看到：依据描述文件helloworld.djinni，在generated-src目录下自动生产了 C++ 和 Java 及 Objective-C 的绑定代码。继续要做的，只是写它们的具体实现 3 编写c++代码 3.1 创建c++工程 这里用 XCode 创建一个 C++ 工程，来测试 C++ 接口代码。 首先，打开 XCode ，选择”Create a new Xcode project”。然后，选择”Command Line Tool”，来新建命令行工具。 “Next”到下一步时，”Language”选择”C++”。 “Next”到下一步，放在[example_root]/ 下 此时目录结构为： 3.2 编写c++实现代码 首先在[example_root]/ 下创建src/cpp目录，用来存放c++实现代码 src/cpp/hello_world_impl.hpp: #pragma once #include &quot;hello_world.hpp&quot; namespace helloworld { class HelloWorldImpl : public helloworld::HelloWorld { public: // Constructor HelloWorldImpl(); // Our method that returns a string std::string get_hello_world(); }; } src/cpp/hello_world_impl.cpp: #include &quot;hello_world_impl.hpp&quot; #include &amp;lt;string&amp;gt; namespace helloworld { std::shared_ptr&amp;lt;HelloWorld&amp;gt; HelloWorld::create() { return std::make_shared&amp;lt;HelloWorldImpl&amp;gt;(); } HelloWorldImpl::HelloWorldImpl() { } std::string HelloWorldImpl::get_hello_world() { std::string myString = &quot;Hello World! &quot;; time_t t = time(0); tm now=*localtime(&amp;amp;t); char tmdescr[200]={0}; const char fmt[]=&quot;%r&quot;; if (strftime(tmdescr, sizeof(tmdescr)-1, fmt, &amp;amp;now)&amp;gt;0) { myString += tmdescr; } return myString; } } 此时目录结构为： 3.3 调试c++代码 接下来，把以下 C++ 接口代码文件，拖动到 Xcode 工程目录来引入(只需引用文件，避免复制。) generated-src/cpp/hello_world.hpp src/cpp/hello_world_impl.cpp src/cpp/hello_world_impl.hpp 此时目录结构为： 编写以下代码： #include &amp;lt;iostream&amp;gt; using namespace std; #include &quot;hello_world_impl.hpp&quot; int main(int argc, const char * argv[]) { helloworld::HelloWorldImpl hw = helloworld::HelloWorldImpl(); string myString = hw.get_hello_world(); cout &amp;lt;&amp;lt; myString &amp;lt;&amp;lt; endl; return 0; } 输出为: Hello World! 02:28:10 PM c++代码调试通过 4 iOS工程 4.1 创建ios工程 在[example_root]/ 下创建ios_project目录 Xcode创建ios工程，命名为HelloWorld 4.2 添加文件 将以下目录中文件加入Xcode（只引用不copy），并虚拟目录分组为oc，c++，djinni [example_root]/generated-src/objc/ [example_root]/generated-src/cpp/ [example_root]/scr/cpp/ [example_root]/deps/djinni/support-lib/objc/ 此时目录结构为： 其中 oc文件夹中为djinni生成的接口文件 c++文件夹中为djinni生成的接口文件和我们自己写的c++实现文件 djinni文件夹中为转换文件（拖入工程就可以了） 4.3 调试 此时我们调用c++写的实现代码，只需要调用我们oc文件夹中的接口文件啦 首先引入头文件 #import &quot;HWHelloWorld.h&quot; 接着调用代码 NSString *str = [[HWHelloWorld create] getHelloWorld]; NSLog(@&quot;str:%@&quot;,str); 输出 Hello World! 02:28:10 PM perfect ！！！ 问答 Q：oc可以和c++混编为objective-c++，那么我们直接oc和c++互相调用不就行了吗，为什么还要用djinni呢？ A：oc可以和c++混编，但是java是需要通过jni。所以使用djinni就是为了统一接口，让同一份c++代码可以被oc和java调用，让c++工程师、objective-c工程师、java工程师能够愉快的一起合作项目。ps：如果只是单纯的想在oc里边混编c++，可以完全不用djinni Q：上边的例子中，是c++写实现代码，java和oc调用，那么有没有oc和java写实现代码，c++调用呢？ A：提出这个问题，说明你对c++跨平台有一定的了解了。当然啦，有调用，就有被调用。如果仔细看的上边的例子的话，会发现我们在helloworld.djinni文件中定义接口的时候，我们是这样写的hello_world = interface +c {}，那么这个+c是什么意思的，+c就是c++来实现代码，供其他平台调用。反过来我们可以写 +j +o，意思就是java和oc写实现代码，c++来调用。这样就实现了c++，java，oc之间的互相调用 Q：djinni与世面上的H5技术跨平台，Xamarin跨平台有什么区别呢？ A：首先来回答djinni和h5、Xamarin的区别。djinni可以说是由下至上的跨平台，主要用底层逻辑代码的跨平台，而UI则交给iOS和android平台去完成。h5则是由上至下的跨平台，UI统一，底层逻辑需要iOS和android各自平台去实现。而Xamarin则可以说是上下齐发力，底层是c#翻译ios的cocoa Touch框架和android框架，UI用自创的的框架统一ios和android平台的UI。 优缺点： djinni：优点是不依赖于IDE，更底层，速度更快，更稳定。缺点是得会c++。如果公司做游戏的，那么c++大神应该会不少（笔者就是这个情况） H5：前几年h5最大的问题，就是性能，渲染太差，这几年好了很多。缺点是很多底层API调用不到，需要各自平台去实现 Xamarin：笔者有幸研究了大半年的Xamarin，翻译了已经上架的一个APP。优点是统一了语言c#。缺点是收费（现在已经免费了），依赖IDE，要用Xamarin Studio或者VS。对习惯了Xcode的coder可能比较难接受，另外一个缺点，就是ios和android已经有很多成熟的库，而xamarin没有。比如笔者要接一个支付宝支付，然而并没有这样的xamarin库，需要使用者自己去binding。 最后，这个问题，选你适合的跨平台解决方案。 问答会持续更新哦 ！！！ 最后 一个根据djinni写成的demo（ios），解决了macOS Sierra下第一次build时出错的问题 原文及demo托管在github上 https://github.com/guojunliu/djinni 如果这篇文章或者demo能帮到你的话，麻烦给个Star，给个星星哦，能让它继续帮到想使用djinni的人</summary></entry></feed>