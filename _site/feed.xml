<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-09-15T20:45:16+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Steve.liu</title><subtitle>A blog of an iOS R&amp;D engineer</subtitle><entry><title type="html">苹果今年再次更新App Store审核指南，放宽App内购限制</title><link href="http://localhost:4000/%E8%8B%B9%E6%9E%9C%E5%86%8D%E6%AC%A1%E6%9B%B4%E6%96%B0App-Store%E5%AE%A1%E6%A0%B8%E6%8C%87%E5%8D%97-%E6%94%BE%E5%AE%BDApp%E5%86%85%E8%B4%AD%E9%99%90%E5%88%B6/" rel="alternate" type="text/html" title="苹果今年再次更新App Store审核指南，放宽App内购限制" /><published>2020-09-15T00:00:00+08:00</published><updated>2020-09-15T00:00:00+08:00</updated><id>http://localhost:4000/%E8%8B%B9%E6%9E%9C%E5%86%8D%E6%AC%A1%E6%9B%B4%E6%96%B0App%20Store%E5%AE%A1%E6%A0%B8%E6%8C%87%E5%8D%97,%E6%94%BE%E5%AE%BDApp%E5%86%85%E8%B4%AD%E9%99%90%E5%88%B6</id><content type="html" xml:base="http://localhost:4000/%E8%8B%B9%E6%9E%9C%E5%86%8D%E6%AC%A1%E6%9B%B4%E6%96%B0App-Store%E5%AE%A1%E6%A0%B8%E6%8C%87%E5%8D%97-%E6%94%BE%E5%AE%BDApp%E5%86%85%E8%B4%AD%E9%99%90%E5%88%B6/">&lt;blockquote&gt;
  &lt;p&gt;2020年9月11日，苹果更新了App Store审核指南，这也是进入2020年后，苹果第二次更新其审核指南。这次更新的主要内容包括App Clip、App内购买、云游戏等多个方面。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中，苹果放宽了对App内购的限制。&lt;/p&gt;

&lt;h2 id=&quot;旧版本审核指南&quot;&gt;旧版本审核指南&lt;/h2&gt;

&lt;p&gt;首先看一下旧版本审核指南（2020/3/4）中可以不使用App内购的情况：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/appleReview/1.png&quot; alt=&quot;旧审核指南&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中可以不使用App内购，而使用其他方式支付的情况只有两种，分别是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;阅读器&lt;/li&gt;
  &lt;li&gt;多平台服务&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;新版本审核指南&quot;&gt;新版本审核指南&lt;/h2&gt;

&lt;p&gt;接下来看一下新版本的审核指南（2020/9/11）中可以不使用App内购的情况：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/appleReview/2.png&quot; alt=&quot;新审核指南&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中可以不使用App内购，而使用其他方式支付的情况有6种，分别是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Reader 阅读器&lt;/li&gt;
  &lt;li&gt;Multiplatform Services 多平台服务&lt;/li&gt;
  &lt;li&gt;Enterprise Services 企业服务&lt;/li&gt;
  &lt;li&gt;Person-to-Person Experiences 一对一体验&lt;/li&gt;
  &lt;li&gt;Goods and Services Outside of the App 应用程序外的商品和服务&lt;/li&gt;
  &lt;li&gt;Free Stand-alone Apps 免费的独立应用程序&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;放宽了app内购限制&quot;&gt;放宽了App内购限制&lt;/h2&gt;

&lt;p&gt;对比下来我们会发现新版的多出了4项可以不使用内购的情况。&lt;/p&gt;

&lt;p&gt;Apple还特别说明了产品方不得主动鼓励或暗示用户可到第三方支付的地方进行购买。&lt;/p&gt;

&lt;p&gt;Apple针对阅读App、跨平台服务、企业服务、一对一体验、免费独立App等不同平台和业务模式进行了单独的详细说明。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;喜欢我你就关注我,&lt;/p&gt;

&lt;p&gt;有话说你就评论我,&lt;/p&gt;

&lt;p&gt;都不干你就点个赞&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/widget/26.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="IAP" /><summary type="html">2020年9月11日，苹果更新了App Store审核指南，这也是进入2020年后，苹果第二次更新其审核指南。这次更新的主要内容包括App Clip、App内购买、云游戏等多个方面。 其中，苹果放宽了对App内购的限制。 旧版本审核指南 首先看一下旧版本审核指南（2020/3/4）中可以不使用App内购的情况： 其中可以不使用App内购，而使用其他方式支付的情况只有两种，分别是： 阅读器 多平台服务 新版本审核指南 接下来看一下新版本的审核指南（2020/9/11）中可以不使用App内购的情况： 其中可以不使用App内购，而使用其他方式支付的情况有6种，分别是： Reader 阅读器 Multiplatform Services 多平台服务 Enterprise Services 企业服务 Person-to-Person Experiences 一对一体验 Goods and Services Outside of the App 应用程序外的商品和服务 Free Stand-alone Apps 免费的独立应用程序 放宽了App内购限制 对比下来我们会发现新版的多出了4项可以不使用内购的情况。 Apple还特别说明了产品方不得主动鼓励或暗示用户可到第三方支付的地方进行购买。 Apple针对阅读App、跨平台服务、企业服务、一对一体验、免费独立App等不同平台和业务模式进行了单独的详细说明。 喜欢我你就关注我, 有话说你就评论我, 都不干你就点个赞</summary></entry><entry><title type="html">iOS14 Widget指北</title><link href="http://localhost:4000/iOS14-WidgetGuide/" rel="alternate" type="text/html" title="iOS14 Widget指北" /><published>2020-08-27T00:00:00+08:00</published><updated>2020-08-27T00:00:00+08:00</updated><id>http://localhost:4000/iOS14-WidgetGuide</id><content type="html" xml:base="http://localhost:4000/iOS14-WidgetGuide/">&lt;blockquote&gt;
  &lt;p&gt;2020 年 6 月 22 日，苹果召开了第一次线上的开发者大会 - WWDC20。这次发布会上宣布了ARM架构Mac芯片（&lt;del&gt;拳打Intel&lt;/del&gt;）、iOS 14 ATT（&lt;del&gt;脚踢Facebook&lt;/del&gt;），可谓是一次载入史册（&lt;del&gt;我是爸爸&lt;/del&gt;）的发布会了，当然还发布了被称为下一个顶级流量入口的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Widget&lt;/code&gt;。&lt;/p&gt;

  &lt;p&gt;踩着八月的尾巴，本次我们就来探究一下Widget。&lt;/p&gt;

  &lt;p&gt;本文会从&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Widget初窥&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Widget开发&lt;/code&gt;两个维度和章节来探究一下Widget，
其中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;初窥&lt;/code&gt;章节会带您简单的了解一下Widget，适合应用决策者阅读；
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;开发&lt;/code&gt;章节会带着您一步一步的完成设计开发Widget，适合程序员阅读。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;widget初窥&quot;&gt;Widget初窥&lt;/h1&gt;

&lt;h2 id=&quot;一widget是什么&quot;&gt;一、Widget是什么&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;In iOS 14, we have a dramatic new Home screen experience, one that is much more dynamic and personalized, with a focus on widgets.
The content is the focus.
This is very important: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;widgets are not mini-apps.&lt;/code&gt;
Think of this as more projecting content from your app onto the Home screen rather than full mini-apps filled with tiny little buttons.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一句话来说：Widget不是迷你应用程序。而是一种新的主屏幕体验，能快速提供用户关心的内容是重点&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/widget/47.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;二widget的特点&quot;&gt;二、Widget的特点&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Glanceable&lt;/code&gt;		一目了然&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Relevant&lt;/code&gt;			早韭晚菘&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Personalized&lt;/code&gt;		量体裁衣&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../images/widget/0.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;要设计一个优秀的Widget，就要先了解Widget的全部特点，了然于胸&lt;/p&gt;

&lt;p&gt;针对Apple提出的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Glanceable&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Relevant&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Personalized&lt;/code&gt;分别用一个成语来形容就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;一目了然&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;早韭晚菘&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;量体裁衣&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;简单来说下这几个特点&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;1glanceable--一目了然一览无余&quot;&gt;1、Glanceable | 一目了然，一览无余&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../images/widget/1.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一个优秀的Widget要一目了然，一览无余。&lt;/p&gt;

&lt;p&gt;普通人每天进入“主屏幕”的次数超过90次，但是在主屏幕仅停留几分钟，就切换到其他App了。&lt;/p&gt;

&lt;p&gt;所以Widget一定要充分利用狭小的屏幕展示最核心的信息，并且要简洁明了。设计新颖，便于快速浏览，高效是一个优秀Widget的核心。&lt;/p&gt;

&lt;p&gt;用户不用思考这个Widget怎么使用，不需要点击任何按钮就可以获得最关心的信息。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2relevant--早韭晚菘&quot;&gt;2、Relevant | 早韭晚菘&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../images/widget/2.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;苹果希望Widget可以和用户紧密结合，与用户的行为所关联，比如早上起床，用户希望看一下天气；中午恰饭，用户希望有人推荐下附近的美食；晚高峰的时候，用户希望了解一下行车路线；晚安的时候，希望记录下次日的行程。&lt;/p&gt;

&lt;p&gt;为此，苹果系统提供了一个叫Smart Stacks（智能叠放）的功能，Smart Stacks是一个Widgets的集合。系统会根据每个人的习惯，自动显示用户当前时间点最需要的Widget。&lt;/p&gt;

&lt;div style=&quot;align:center&quot;&gt;&lt;img src=&quot;../images/widget/3.gif&quot; /&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3personalized--量体裁衣&quot;&gt;3、Personalized  量体裁衣&lt;/h3&gt;

&lt;h4 id=&quot;31-大小&quot;&gt;3.1 大小&lt;/h4&gt;

&lt;p&gt;Widget要能为用户提供个性化的服务，比如天气Widget，需要能为不同的用户提供不同细节的天气情况。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/widget/4.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为此Apple提供三种不同大小的小部件&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;systemSmall&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;systemMedium&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;systemLarge&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中systemSmall大小为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2*2 Icon&lt;/code&gt;，systemMedium大小为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;4*2 Icon&lt;/code&gt;，systemLarge大小为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;4*4 Icon&lt;/code&gt;，具体的显示效果如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/widget/13.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;32-个性化配置&quot;&gt;3.2 个性化配置&lt;/h4&gt;

&lt;p&gt;另一方面Widget需要能为不同城市的用户提供当地的天气情况。&lt;/p&gt;

&lt;p&gt;为此Apple在创建Widget时为开发者提供了两种类型：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StaticConfiguration&lt;/code&gt; ：对于没有用户可配置属性的窗口小部件,也就是用户无需配置，展示的内容只和用户信息有关系。例如，显示一般市场信息的股市窗口小部件，或显示趋势头条的新闻窗口小部件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IntentConfiguration&lt;/code&gt; ：对于具有用户可配置属性的窗口小部件,也就是支持用户配置及用户意图的推测。您使用SiriKit自定义意图来定义属性。例如，需要一个城市的邮政编码的天气小部件，或者需要一个跟踪号的包裹跟踪小部件。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../images/widget/11.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;需要说明的是，IntentConfiguration并不需要编写代码，只需要简单的配置，Xcode 会自动帮你生成对应的代码和类型。&lt;/p&gt;

&lt;h4 id=&quot;33-黑暗模式&quot;&gt;3.3 黑暗模式&lt;/h4&gt;

&lt;p&gt;此外Widget还支持系统的黑暗模式&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/widget/12.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;三widget的本质&quot;&gt;三、Widget的本质&lt;/h2&gt;

&lt;p&gt;Widget的本质是一系列静态视图堆叠而成的集合，不同的时间点展示不同的视图&lt;/p&gt;

&lt;p&gt;这里要引入Widget的核心Timeline&lt;/p&gt;

&lt;p&gt;顾名思义，Timeline就是一条时间线，在对应的时间点发生对应的事件&lt;/p&gt;

&lt;p&gt;许多Widget具有可预测的时间点，在这些时间点更新其内容是有意义的。例如，显示天气信息的小部件可能会在一整天内每小时更新一次温度。股市窗口小部件可以在公开市场时间频繁更新其内容，但周末则不用完全更新。通过提前计划这些时间，生成不同的视图放入时间线中，WidgetKit会在适当的时间到来时自动刷新您的窗口小部件。&lt;/p&gt;

&lt;p&gt;这也决定了Widget基本上不能实时更新&lt;/p&gt;

&lt;p&gt;另外值得一提的是，WidgetKit会把 Timelines 所定义的Views 结构信息缓存到磁盘，然后在刷新的时候才通过 JIT 的方式来渲染。这使得系统可以在极低电量开销下为众多 Widgets 处理 Timelines 信息。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/widget/6.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;四用户交互&quot;&gt;四、用户交互&lt;/h2&gt;

&lt;p&gt;不好意思，没有交互！！！&lt;/p&gt;

&lt;p&gt;为了实现以上的特点，Apple也移除限制了Widget的一些功能&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;不能交互&lt;/li&gt;
  &lt;li&gt;不能播放动画&lt;/li&gt;
  &lt;li&gt;不能播放视频&lt;/li&gt;
  &lt;li&gt;不支持滚动&lt;/li&gt;
  &lt;li&gt;不支持主动刷新视图&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;唯一支持的只有用户点击Widget唤起主App&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/widget/5.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中点击唤起主App有两种方案，分别是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;widgetURL&lt;/li&gt;
  &lt;li&gt;Link&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;widgetURL唤起App的点击区域是Widget的所有区域，这种方案适合简单元素，单一逻辑的小部件&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/widget/8.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于systemSmall类型的小部件，只支持widgetURL唤起方式&lt;/p&gt;

&lt;p&gt;针对&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;systemMedium &lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;systemLarge &lt;/code&gt;还可以使用更细分的Link唤起方式，这种唤起方式能让小部件通过不同元素的点击唤起App的不同页面，让开发者有更多的施展空间&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/widget/9.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;举个简单的例子，widgetURL可应用于天气小部件，博客小部件，点击直达App；&lt;/p&gt;

&lt;p&gt;Link可用于备忘录和日历小部件，点击不同的备忘录和日期直接跳转到对应的备忘录详情和待办详情页面&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/widget/10.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;widget初窥总结&quot;&gt;Widget初窥总结&lt;/h2&gt;

&lt;p&gt;Widget的出现犹如在一潭死水的iOS桌面上泛起了一片涟漪，一定会有很多App来争夺这块肥肉一般的流量入口。&lt;/p&gt;

&lt;p&gt;但是仔细研究一下会发现，Apple这次推出的Widget非常克制，并没有非常激进，&lt;/p&gt;

&lt;p&gt;俗话说：喜欢是放肆,但爱就是克制。这里不得不再次引用Apple在Widget介绍中出现频率最高的话&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;widgets are not mini-apps&lt;/code&gt;，因为Widget在设计之初就是为了能使用最少的成本，向用户提供最核心的信息。为了尽可能的减少用户成本（电量，网络等）和提高用户体验，Apple在技术层面上做了很多限制，限制了非常多的功能，大大削弱了Widget的地位和重要程度，也降低了开发者实现的热情和积极性&lt;/p&gt;

&lt;p&gt;其实每年Apple更新的新技术只有很少的一部分能应用到App上，希望这次的Widget能有动力让大家结合自己的App，给自己的App带来更多的流量，也能给用户带来更好的体验。&lt;/p&gt;

&lt;hr /&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;widget开发&quot;&gt;Widget开发&lt;/h1&gt;

&lt;p&gt;重头戏来啦，接下来让我们一步一步设计编写出优秀的小部件吧&lt;/p&gt;

&lt;p&gt;开始之前，首先我们要介绍下Widget的开发语言，Apple特别指定了小部件只能使用SwiftUI来开发&lt;/p&gt;

&lt;h2 id=&quot;一swiftui&quot;&gt;一、SwiftUI&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/widget/14.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在iOS主流的开发语言还是Objective-C，那Apple为什么要选择2019 WWDC发布迄今为止只有一年的SwiftUI呢？&lt;/p&gt;

&lt;p&gt;首先，从一开始就将小部件实现多平台化是Apple的一个目标，SwiftUI在跨设备展示的能力上是一把大杀器；&lt;/p&gt;

&lt;p&gt;其次SwiftUI还使自动布局和暗模式等功能变得非常容易，降低了适配等开发成本，对不需要太多元素的小部件来说，SwiftUI重点关注布局的特点无疑是最合适的；&lt;/p&gt;

&lt;p&gt;从另一方面来讲，只有使用 SwiftUI 才能达到我们上边说的对于 Widget 的限制。如果可以使用 Objective-C UIKit 的话，我们强大的开发者可能会想出无数的黑科技来忽略Apple真的小部件的限制。比如开发无法使用 UIViewRepresentable 来桥接 UIKit；&lt;/p&gt;

&lt;p&gt;最后Apple也夹带了自己的私心，Apple今年已经将 Swift 语言和 SwiftUI 的重要程度提升到了一个新的高度，Swift已经可以独立于Foundtion框架，那么对应的SwiftUI也应该不依赖于UIKit框架了，强行使用SwiftUI可以使开发人员尽可能容易地将其学习其内容并应用于iOS，iPadOS和macOS，&lt;/p&gt;

&lt;p&gt;毕竟5月份卡位第20位Objective-C在6月份已经跌出了前20&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/widget/16.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里要重点说明一下，Widget只要使用任何 UIKit 的元素就会直接 Crash&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;二将小部件目标添加到您的应用&quot;&gt;二、将小部件目标添加到您的应用&lt;/h2&gt;

&lt;p&gt;窗口小部件扩展模板提供了创建窗口小部件的起点。单个小部件扩展可以包含多种小部件。例如，一个体育应用程序可能有一个显示团队信息的小部件，另一个显示游戏时间表的小部件。一个小部件扩展可以包含两个小部件。尽管建议将所有窗口小部件包含在一个窗口小部件扩展中，但如有必要，可以添加多个扩展。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在Xcode中打开您的应用程序项目，然后选择“文件”&amp;gt;“新建”&amp;gt;“目标”。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;从“应用程序扩展”组中，选择“窗口小部件扩展”，然后单击“下一步”。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;输入您的包名。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果窗口小部件提供了用户可配置的属性，请选中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Include Configuration Intent&lt;/code&gt;复选框。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;单击完成。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/widget/15.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;重点：小部件不仅支持Swift项目，同样也支持Objective-C项目，OC小伙伴不用担心啦&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;创建完小部件之后，我们会多出一个SmileEverydayWidget.swift文件，这已经是一个可以run起来的小部件了，因为我们接下来要逐个方法来分析，所以先将文件全文展示如下&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
//  SmileEverydayWidget.swift
//  SmileEverydayWidget
//
//  Created by steve on 2020/8/28.
//

import WidgetKit
import SwiftUI

struct Provider: TimelineProvider {
    public typealias Entry = SimpleEntry

    public func snapshot(with context: Context, completion: @escaping (SimpleEntry) -&amp;gt; ()) {
        let entry = SimpleEntry(date: Date())
        completion(entry)
    }

    public func timeline(with context: Context, completion: @escaping (Timeline&amp;lt;Entry&amp;gt;) -&amp;gt; ()) {
        var entries: [SimpleEntry] = []

        // Generate a timeline consisting of five entries an hour apart, starting from the current date.
        let currentDate = Date()
        for hourOffset in 0 ..&amp;lt; 5 {
            let entryDate = Calendar.current.date(byAdding: .hour, value: hourOffset, to: currentDate)!
            let entry = SimpleEntry(date: entryDate)
            entries.append(entry)
        }

        let timeline = Timeline(entries: entries, policy: .atEnd)
        completion(timeline)
    }
}

struct SimpleEntry: TimelineEntry {
    public let date: Date
}

struct PlaceholderView : View {
    var body: some View {
        Text(&quot;Placeholder View&quot;)
    }
}

struct SmileEverydayWidgetEntryView : View {
    var entry: Provider.Entry

    var body: some View {
        Text(entry.date, style: .time)
    }
}

@main
struct SmileEverydayWidget: Widget {
    private let kind: String = &quot;SmileEverydayWidget&quot;

    public var body: some WidgetConfiguration {
        StaticConfiguration(kind: kind, provider: Provider(), placeholder: PlaceholderView()) { entry in
            SmileEverydayWidgetEntryView(entry: entry)
        }
        .configurationDisplayName(&quot;My Widget&quot;)
        .description(&quot;This is an example widget.&quot;)
    }
}

struct SmileEverydayWidget_Previews: PreviewProvider {
    static var previews: some View {
        /*@START_MENU_TOKEN@*/Text(&quot;Hello, World!&quot;)/*@END_MENU_TOKEN@*/
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里的概念和代码比较多，接下来我们一个一个来解释&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;三widget-api&quot;&gt;三、Widget API&lt;/h2&gt;

&lt;p&gt;首先我们从带有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt;字段的方法来说起，&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@main
struct SmileEverydayWidget: Widget {
    private let kind: String = &quot;com.steve.liu.smileEverydayWidget&quot;

    public var body: some WidgetConfiguration {
        StaticConfiguration(kind: kind, provider: Provider(), placeholder: PlaceholderView()) { entry in
            SmileEverydayWidgetEntryView(entry: entry)
        }
        .configurationDisplayName(&quot;My Widget&quot;)
        .description(&quot;This is an example widget.&quot;)
        .supportedFamilies([.systemSmall, .systemMedium, .systemLarge])
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;大家都知道带有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt;标识的方法都是程序的入口&lt;/p&gt;

&lt;p&gt;这段代码使用SwiftUI声明了一个名为SmileEverydayWidget的小部件，其中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StaticConfiguration&lt;/code&gt;是小部件的初始化方法，它有几个参数：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kind&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;provider&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;placeholder&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;../images/widget/31.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kind&lt;/code&gt;是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;标识小部件的字符串,并且应描述小部件所代表的内容。即小部件的包名&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;provider&lt;/code&gt;为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;时间线提供者&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PlaceholderView&lt;/code&gt;为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;占位视图&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;同时也提供了一些方法，例如&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configurationDisplayName()&lt;/code&gt;设置小部件显示的名称&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;description()&lt;/code&gt;设置小部件的描述&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;supportedFamilies()&lt;/code&gt;设置小部件支持的尺寸&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;这里有一个重点，为了使某个应用程序的窗口小部件出现在窗口小部件库中，用户必须在安装该应用程序后至少启动一次包含该窗口小部件的应用程序。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;四widgetentryview&quot;&gt;四、WidgetEntryView&lt;/h2&gt;

&lt;p&gt;WidgetEntryView就是使用SwiftUI布局的小部件视图&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct SmileEverydayWidgetEntryView : View {
    var entry: Provider.Entry

    var body: some View {
        Text(entry.date, style: .time)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;例如这个小部件视图就简单的展示了当前的时间&lt;/p&gt;

&lt;p&gt;接下来我们可以将默认的布局更改为我们自己想要的布局，例如我在设置了显示文本的字体和小部件的背景图&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct SmileEverydaWidgetEntryView : View {
    var entry: Provider.Entry

    var body: some View {
        
        return Text(entry.message)
            .background(Image(entry.backgroundImageStr))
            .font(.callout)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;五placeholderview&quot;&gt;五、PlaceholderView&lt;/h2&gt;

&lt;p&gt;每种小部件都需要提供占位符UI。&lt;/p&gt;

&lt;p&gt;占位符UI是窗口小部件的默认内容。&lt;/p&gt;

&lt;p&gt;它应该代表您的小部件类型，但仅此而已。&lt;/p&gt;

&lt;p&gt;此用户界面中不应有任何用户数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/widget/17.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;想象一下&lt;/p&gt;

&lt;p&gt;如果在用户的主屏幕上出现如下的场景，那么你的小部件离被移除可能已经不远了&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/widget/19.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;六timelineentry&quot;&gt;六、TimelineEntry&lt;/h2&gt;

&lt;p&gt;我们知道小部件是按照时间线来展示的，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TimelineEntry&lt;/code&gt;时间线上的一个个条目&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct SimpleEntry: TimelineEntry {
    public let date: Date
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;TimelineEntry有一个必须有的属性就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;date&lt;/code&gt;，也就是这个条目在时间线上的具体时间&lt;/p&gt;

&lt;p&gt;另外开发者可以在TimelineEntry里自定义各种属性，用来给小部件视图提供数据&lt;/p&gt;

&lt;p&gt;例如我在TimelineEntry里自定义了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;message &lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;backgroundImageStr &lt;/code&gt;属性，用来显示小部件上的文字和背景图片&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct SimpleEntry: TimelineEntry {
    public let date: Date
    public let message: String
    public let backgroundImageStr : String
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;七timelineprovider&quot;&gt;七、TimelineProvider&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TimelineProvider&lt;/code&gt; 是一个提供了上述我们所说的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TimelineEntry&lt;/code&gt;集合的对象&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/widget/39.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们来看下具体的代码：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct Provider: TimelineProvider {
    public typealias Entry = SimpleEntry

    public func snapshot(with context: Context, completion: @escaping (SimpleEntry) -&amp;gt; ()) {
        let entry = SimpleEntry(date: Date())
        completion(entry)
    }

    public func timeline(with context: Context, completion: @escaping (Timeline&amp;lt;Entry&amp;gt;) -&amp;gt; ()) {
        var entries: [SimpleEntry] = []

        // Generate a timeline consisting of five entries an hour apart, starting from the current date.
        let currentDate = Date()
        for hourOffset in 0 ..&amp;lt; 5 {
            let entryDate = Calendar.current.date(byAdding: .hour, value: hourOffset, to: currentDate)!
            let entry = SimpleEntry(date: entryDate)
            entries.append(entry)
        }

        let timeline = Timeline(entries: entries, policy: .atEnd)
        completion(timeline)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中包含两个方法&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;snapshot()&lt;/li&gt;
  &lt;li&gt;timeline()&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;1snapshot-快照&quot;&gt;1、snapshot 快照&lt;/h4&gt;

&lt;p&gt;为了在小部件库中显示小部件，WidgetKit 要求提供者提供预览快照， 即&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;snapshot()&lt;/code&gt;，这个方法里主要提供了一些&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;示例数据，最好是真实数据&lt;/code&gt;，用于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;时间线不能展示&lt;/code&gt;的时候展示给用户&lt;/p&gt;

&lt;p&gt;需要说明的是，快照是系统需要快速显示单个条目的位置。&lt;/p&gt;

&lt;p&gt;因此，您的扩展程序必须尽快返回视图，因为这样做时，用户会在iOS上漂亮的Widget Gallery中看到真正的Widget。&lt;/p&gt;

&lt;p&gt;这不是我们在设计时必须提供的屏幕截图或图像。这是用户在iOS，iPadOS和macOS上真正的小部件体验。&lt;/p&gt;

&lt;p&gt;在大多数情况下，时间轴的第一个条目和快照可以作为同一条目返回，因此，在“小工具库”中看到的就是用户将其添加到设备中时得到的内容。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/widget/20.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;例如我们在Widget Gallery中添加电池小部件时，小部件此时在Widget Gallery中展示的就是当前设备电池信息的实时数据的快照，而不是一些虚假的数据，这个时候小部件的数据是什么样子，用户添加到主屏幕上之后小部件的数据就是什么样子，从而提高用户的体验。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;对比&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;小部件里有两个比较类似的概念，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PlaceholderView&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;snapshot&lt;/code&gt;，都是一种占位解决方案，不同的是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PlaceholderView&lt;/code&gt;是在主屏幕上无法快速获取数据时的一种占位视图，不至于显示loading或者白屏给用户看；而&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;snapshot&lt;/code&gt;主要用于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Widget Gallery&lt;/code&gt;中，用来提高用户体验的，一般来说，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;snapshot &lt;/code&gt;就是时间线的第一帧&lt;/p&gt;

&lt;h4 id=&quot;2timeline&quot;&gt;2、timeline&lt;/h4&gt;

&lt;p&gt;在请求初始快照后，WidgetKit调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;timeline&lt;/code&gt;以请求提供者的常规时间轴。时间轴由一个或多个时间轴条目&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TimelineEntry&lt;/code&gt;以及一个重载策略&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReloadPolicy&lt;/code&gt;组成，该重载策略通知WidgetKit何时请求后续时间轴。&lt;/p&gt;

&lt;p&gt;关于重载策略，提供了以下几种策略&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;atEnd&lt;/code&gt;: 是指 Timeline 执行到最后一个时间片的时候再刷新。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;atAfter&lt;/code&gt;: 是指在某个时间以后有规律的刷新&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;never&lt;/code&gt;：是指以后不需要刷新了。什么时候需要重新刷新需要 App 重新告知 Widget&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;根据上边的分析，我们可以将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TimelineProvider &lt;/code&gt;改造如下&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct Provider: TimelineProvider {
    public typealias Entry = SimpleEntry

    public func snapshot(with context: Context, completion: @escaping (SimpleEntry) -&amp;gt; ()) {
        let date = Date()
        let message = &quot;蒹葭苍苍，白露为霜。所谓伊人，在水一方。&quot;
        let backgroundImageStr = &quot;bg7&quot;
        
        
        let entry = SimpleEntry(date: date, message: message, backgroundImageStr: backgroundImageStr)
        completion(entry)
    }

    public func timeline(with context: Context, completion: @escaping (Timeline&amp;lt;Entry&amp;gt;) -&amp;gt; ()) {
        var entries: [SimpleEntry] = []
        
        var currentDate = Date()
        var nextUpdateDate = Calendar.current.date(byAdding: .second, value: 3, to: currentDate)!
        
        let message = &quot;蒹葭苍苍，白露为霜。所谓伊人，在水一方。\n溯洄从之，道阻且长；溯游从之，宛在水中央。\n蒹葭凄凄，白露未晞。所谓伊人，在水之湄。&quot;
        let backgroundImageStr = &quot;bg&quot;
        
        
        let formatter = DateFormatter()
        formatter.dateFormat = &quot;yyyy-MM-dd HH:mm:ss&quot;
        var currentDateStr = &quot;&quot;
        var nextUpdateDateStr = &quot;&quot;

        let longUuid = UUID().uuidString
        let range: Range = longUuid.range(of: &quot;-&quot;)!
        let location: Int = longUuid.distance(from: longUuid.startIndex, to: range.lowerBound)
        let uuid = longUuid.prefix(location)
        
        for i in 1 ..&amp;lt; 10 {
            
            var msg = &quot;&quot;
            
            currentDate = nextUpdateDate;
            nextUpdateDate = Calendar.current.date(byAdding: .second, value: 3, to: currentDate)!
            
            currentDateStr = formatter.string(from: currentDate)
            nextUpdateDateStr = formatter.string(from: nextUpdateDate)
            
            msg.append(message)
            msg.append(&quot;\n时间轴ID &quot; + uuid);
            msg.append(&quot;\n时间轴第&quot; + String(i+1) + &quot;个视图&quot;)
            msg.append(&quot;\n本次视图开始时间 &quot; + currentDateStr)
            msg.append(&quot;\n下次视图开始时间 &quot; + nextUpdateDateStr)
            
            let entry = SimpleEntry(date: currentDate, message: msg, backgroundImageStr: backgroundImageStr+String(i))
            
            entries.append(entry)
            print(String(i))
        }
        
        let timeline = Timeline(entries: entries, policy: .atEnd)
        completion(timeline)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这段代码里我们提供了一个古诗词的快照&lt;/p&gt;

&lt;p&gt;并生成了一个时间线，其中时间线里包含了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10个entry，且每个entry 间隔10s&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;entry文本拼接显示了&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;展示文本（诗经）&lt;/li&gt;
  &lt;li&gt;时间轴ID&lt;/li&gt;
  &lt;li&gt;本次视图开始时间&lt;/li&gt;
  &lt;li&gt;下次视图开始时间&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下边我们来看一下真实run出来的效果&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/widget/21.gif&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;到此为止我们就有了一个可以在主屏幕上展示的小部件了&lt;/p&gt;

&lt;p&gt;并且能根据时间线展示不同的视图了。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;七reload-timeline-使小部件保持最新&quot;&gt;七、Reload Timeline 使小部件保持最新&lt;/h2&gt;

&lt;p&gt;为了使我们的小部件能随时提供最新的，而不是过期的信息，我们需要不时的对小部件进行更新。&lt;/p&gt;

&lt;p&gt;我们已经知道了小部件的本质是一系列的视图堆叠，那么更新小部件就是更新这些视图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/widget/28.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;比如一个有三个视图的小部件，预测了现在和未来3小时的天气预报，这个小部件显示步骤如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/widget/22.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但是有一个很重要的问题就是时间线是我们预测出来的，是预测就会有偏差。比如天气预报，预报2小时后有雨，但是随着天气的变化，2小时后变成晴天了，这个时候我们如果不更新小部件上的时间线，就会在2小时后给用户提供错误的信息。&lt;/p&gt;

&lt;p&gt;为此我们需要在有信息变化的时候重新显示新的视图，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/widget/23.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为了是我们的小部件信息准确无误，首先我们需要了解下小部件是如何刷新的&lt;/p&gt;

&lt;p&gt;很不幸，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Widget 的刷新完全由 WidgetCenter控制&lt;/code&gt;。开发者无法通过任何 API 去主动刷新 Widget 的页面，只能告知 WidgetCenter，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Timeline 需要刷新了&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;所以我们不能直接刷新小部件的视图，而是要通过生成一个新的时间线来替换旧的时间线，Reload Timeline 并不是直接刷新 Widget，而是 WidgetCenter 重新向 Widget 请求下一阶段的数据。&lt;/p&gt;

&lt;p&gt;其中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reload Timeline&lt;/code&gt;分为两种方式&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;System Reloads&lt;/li&gt;
  &lt;li&gt;App Reloads&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;1system-reloads&quot;&gt;1、System Reloads&lt;/h4&gt;

&lt;p&gt;这个行为由系统主动发起，会调用一次 Reload Timeline 向 Widget 请求下一阶段刷新的数据。系统除了会按时发起 System Reloads 之外，还会动态决策每个不同的 TimeLine 的 System Reloads 的频次。比如被点击次数很大程度上直接决定了 System Reloads 的频率，点击率越高，更新频次越快，当然还有一些由于设备环境变化触发的行为也会触发 System Reloads，比如设备时间进行了变更。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/widget/42.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;很显然这种方案不能很好的解决我们上边的问题&lt;/p&gt;

&lt;h4 id=&quot;2app-reloads&quot;&gt;2、App Reloads&lt;/h4&gt;

&lt;p&gt;这种行为指的是App主动通知小部件，你需要更新信息了。这里边根据App的当前的前后台状态又分为两种方式&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;应用在前台运行&lt;/li&gt;
  &lt;li&gt;应用在后台运行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当应用在前台运行的时候，App 可以直接使用WidgetCenter的 API 来 Reload Timeline；而当应用处于后台时，可以使用后台推送（Background Notification）来 Reload Timeline。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/widget/44.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;除了这些，给Timeline设定合适的刷新策略也是很重要的手段&lt;/p&gt;

&lt;p&gt;合理的组合使用这些刷新机制，能够极大的提高Widget信息的准确性&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/widget/46.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;八交互&quot;&gt;八、交互&lt;/h2&gt;

&lt;p&gt;前边我们说过，widget和app交互有两种方式&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SwiftUI widgetURL API&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SwiftUI Link API&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这两种方式的本质都是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;URL Schemes&lt;/code&gt;，只要监听&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SceneDelegate&lt;/code&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scene:openURLContexts:&lt;/code&gt;就可以了&lt;/p&gt;

&lt;p&gt;由于Schemes大家都太熟悉了，关于如何高效快速准确的传递参数，这里就不展开讲了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/widget/35.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;九设计漂亮的小部件&quot;&gt;九、设计漂亮的小部件&lt;/h2&gt;

&lt;p&gt;如果你已经看到了这里，并且已经理解了上述的讲解，你已经具备了开发小部件的能力。&lt;/p&gt;

&lt;p&gt;那么有哪些关键点能给自己的小部件锦上添花呢？&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;去除额外的App信息&lt;/code&gt;：系统会在小部件下方自动显示你的应用名称，因此你无需在内容中重复App的名称，Icon，而是要通过颜色，布局和图像来联系您的App&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;简洁的描述&lt;/code&gt;。小部件库中显示的描述可以帮助人们理解每个小部件的功能。从动作动词开始描述通常效果很好；例如，“查看当前天气状况和位置预测”或“跟踪即将举行的活动和会议”。避免包含不必要的短语来引用窗口小部件本身，例如“此窗口小部件显示…”，“使用此窗口小部件…”或“添加此窗口小部件”。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;舒适的信息密度&lt;/code&gt;：一览无余。当内容显得稀疏时，小部件可能看起来是多余的；当内容太密集时，小部件将无法浏览。如果要包含很多信息，请避免让小部件成为难以解析的项的拼贴。寻求整理内容的方法，以便人们可以立即掌握关键部分，并以更长的时间查看相关细节。您可能还考虑创建一个较大的小部件，并寻找可以用图形替换文本而又不会失去清晰度的位置。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;明智地使用颜色&lt;/code&gt;：丰富，美丽的色彩吸引眼球，但它们绝不能阻止人们一眼就吸收小部件的信息。使用颜色可以增强小部件的外观，而不会与小部件的内容竞争。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;使用系统字体，支持系统功能&lt;/code&gt;：例如 支持黑暗模式；使用SF Pro和使用系统字体；文本可缩放。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/widget/12.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;设计一个真实的预览以显示在小部件库中&lt;/code&gt;：突出显示小部件的外观和功能可帮助人们做出明智的决定，并鼓励他们添加小部件。您可以在小部件预览中显示真实数据，但是如果数据生成或加载所需的时间太长，请显示真实的模拟数据。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;设计占位符内容，以帮助人们识别您的小部件&lt;/code&gt;。小部件在加载数据时显示占位符内容。通过将UI的静态部分与代表实际内容的半透明形状结合起来，可以创建有效的预览。例如，您可以使用不同宽度的矩形来建议文本行，并使用圆环或正方形代替字形和图像。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/widget/24.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;图片适配屏幕尺寸&lt;/code&gt;：确保图片在大部件和小部件下都不会压缩&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/widget/25.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;十围之木始生如蘖&quot;&gt;十围之木，始生如蘖&lt;/h2&gt;

&lt;p&gt;简单的总结一下&lt;/p&gt;

&lt;p&gt;一个优秀的小部件是完全可以提高用户体验，成为很好的流量入口，给App带来巨大的商业价值。&lt;/p&gt;

&lt;p&gt;但是要设计一个优秀的小部件也并非易事。&lt;/p&gt;

&lt;p&gt;本文抛砖引玉，希望大家能设计出更多优秀的小部件。&lt;/p&gt;

&lt;p&gt;本次的Widget指北到这里就结束了，万字不易，多多传播。&lt;/p&gt;

&lt;p&gt;喜欢我你就关注我,&lt;/p&gt;

&lt;p&gt;有话说你就评论我,&lt;/p&gt;

&lt;p&gt;都不干你就点个赞&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/widget/26.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Demo&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/guojunliu/Widget&quot;&gt;SmileEveryday&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;参考&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2020/10028/&quot;&gt;Meet WidgetKit&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/design/human-interface-guidelines/ios/system-capabilities/widgets/&quot;&gt;Human Interface Guidelines&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/documentation/widgetkit/creating-a-widget-extension&quot;&gt;Creating a Widget Extension&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/documentation/widgetkit/keeping-a-widget-up-to-date&quot;&gt;Keeping a Widget Up To Date&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ%3D%3D&amp;amp;idx=1&amp;amp;mid=2650409113&amp;amp;scene=21&amp;amp;sn=8da77e73f42e4d24ae20f6a86dfa5a4a#wechat_redirect&quot;&gt;Apple Widget：下一个顶级流量入口？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="iOS14" /><summary type="html">2020 年 6 月 22 日，苹果召开了第一次线上的开发者大会 - WWDC20。这次发布会上宣布了ARM架构Mac芯片（拳打Intel）、iOS 14 ATT（脚踢Facebook），可谓是一次载入史册（我是爸爸）的发布会了，当然还发布了被称为下一个顶级流量入口的Widget。 踩着八月的尾巴，本次我们就来探究一下Widget。 本文会从Widget初窥和Widget开发两个维度和章节来探究一下Widget， 其中初窥章节会带您简单的了解一下Widget，适合应用决策者阅读； 开发章节会带着您一步一步的完成设计开发Widget，适合程序员阅读。 Widget初窥 一、Widget是什么 In iOS 14, we have a dramatic new Home screen experience, one that is much more dynamic and personalized, with a focus on widgets. The content is the focus. This is very important: widgets are not mini-apps. Think of this as more projecting content from your app onto the Home screen rather than full mini-apps filled with tiny little buttons. 一句话来说：Widget不是迷你应用程序。而是一种新的主屏幕体验，能快速提供用户关心的内容是重点 二、Widget的特点 Glanceable 一目了然 Relevant 早韭晚菘 Personalized 量体裁衣 要设计一个优秀的Widget，就要先了解Widget的全部特点，了然于胸 针对Apple提出的Glanceable、Relevant、Personalized分别用一个成语来形容就是一目了然、早韭晚菘、量体裁衣 简单来说下这几个特点 1、Glanceable | 一目了然，一览无余 一个优秀的Widget要一目了然，一览无余。 普通人每天进入“主屏幕”的次数超过90次，但是在主屏幕仅停留几分钟，就切换到其他App了。 所以Widget一定要充分利用狭小的屏幕展示最核心的信息，并且要简洁明了。设计新颖，便于快速浏览，高效是一个优秀Widget的核心。 用户不用思考这个Widget怎么使用，不需要点击任何按钮就可以获得最关心的信息。 2、Relevant | 早韭晚菘 苹果希望Widget可以和用户紧密结合，与用户的行为所关联，比如早上起床，用户希望看一下天气；中午恰饭，用户希望有人推荐下附近的美食；晚高峰的时候，用户希望了解一下行车路线；晚安的时候，希望记录下次日的行程。 为此，苹果系统提供了一个叫Smart Stacks（智能叠放）的功能，Smart Stacks是一个Widgets的集合。系统会根据每个人的习惯，自动显示用户当前时间点最需要的Widget。 3、Personalized 量体裁衣 3.1 大小 Widget要能为用户提供个性化的服务，比如天气Widget，需要能为不同的用户提供不同细节的天气情况。 为此Apple提供三种不同大小的小部件 systemSmall systemMedium systemLarge 其中systemSmall大小为2*2 Icon，systemMedium大小为4*2 Icon，systemLarge大小为4*4 Icon，具体的显示效果如下 3.2 个性化配置 另一方面Widget需要能为不同城市的用户提供当地的天气情况。 为此Apple在创建Widget时为开发者提供了两种类型： StaticConfiguration ：对于没有用户可配置属性的窗口小部件,也就是用户无需配置，展示的内容只和用户信息有关系。例如，显示一般市场信息的股市窗口小部件，或显示趋势头条的新闻窗口小部件。 IntentConfiguration ：对于具有用户可配置属性的窗口小部件,也就是支持用户配置及用户意图的推测。您使用SiriKit自定义意图来定义属性。例如，需要一个城市的邮政编码的天气小部件，或者需要一个跟踪号的包裹跟踪小部件。 需要说明的是，IntentConfiguration并不需要编写代码，只需要简单的配置，Xcode 会自动帮你生成对应的代码和类型。 3.3 黑暗模式 此外Widget还支持系统的黑暗模式 三、Widget的本质 Widget的本质是一系列静态视图堆叠而成的集合，不同的时间点展示不同的视图 这里要引入Widget的核心Timeline 顾名思义，Timeline就是一条时间线，在对应的时间点发生对应的事件 许多Widget具有可预测的时间点，在这些时间点更新其内容是有意义的。例如，显示天气信息的小部件可能会在一整天内每小时更新一次温度。股市窗口小部件可以在公开市场时间频繁更新其内容，但周末则不用完全更新。通过提前计划这些时间，生成不同的视图放入时间线中，WidgetKit会在适当的时间到来时自动刷新您的窗口小部件。 这也决定了Widget基本上不能实时更新 另外值得一提的是，WidgetKit会把 Timelines 所定义的Views 结构信息缓存到磁盘，然后在刷新的时候才通过 JIT 的方式来渲染。这使得系统可以在极低电量开销下为众多 Widgets 处理 Timelines 信息。 四、用户交互 不好意思，没有交互！！！ 为了实现以上的特点，Apple也移除限制了Widget的一些功能 不能交互 不能播放动画 不能播放视频 不支持滚动 不支持主动刷新视图 唯一支持的只有用户点击Widget唤起主App 其中点击唤起主App有两种方案，分别是： widgetURL Link widgetURL唤起App的点击区域是Widget的所有区域，这种方案适合简单元素，单一逻辑的小部件 对于systemSmall类型的小部件，只支持widgetURL唤起方式 针对systemMedium 和systemLarge 还可以使用更细分的Link唤起方式，这种唤起方式能让小部件通过不同元素的点击唤起App的不同页面，让开发者有更多的施展空间 举个简单的例子，widgetURL可应用于天气小部件，博客小部件，点击直达App； Link可用于备忘录和日历小部件，点击不同的备忘录和日期直接跳转到对应的备忘录详情和待办详情页面 Widget初窥总结 Widget的出现犹如在一潭死水的iOS桌面上泛起了一片涟漪，一定会有很多App来争夺这块肥肉一般的流量入口。 但是仔细研究一下会发现，Apple这次推出的Widget非常克制，并没有非常激进， 俗话说：喜欢是放肆,但爱就是克制。这里不得不再次引用Apple在Widget介绍中出现频率最高的话widgets are not mini-apps，因为Widget在设计之初就是为了能使用最少的成本，向用户提供最核心的信息。为了尽可能的减少用户成本（电量，网络等）和提高用户体验，Apple在技术层面上做了很多限制，限制了非常多的功能，大大削弱了Widget的地位和重要程度，也降低了开发者实现的热情和积极性 其实每年Apple更新的新技术只有很少的一部分能应用到App上，希望这次的Widget能有动力让大家结合自己的App，给自己的App带来更多的流量，也能给用户带来更好的体验。 Widget开发 重头戏来啦，接下来让我们一步一步设计编写出优秀的小部件吧 开始之前，首先我们要介绍下Widget的开发语言，Apple特别指定了小部件只能使用SwiftUI来开发 一、SwiftUI 现在iOS主流的开发语言还是Objective-C，那Apple为什么要选择2019 WWDC发布迄今为止只有一年的SwiftUI呢？ 首先，从一开始就将小部件实现多平台化是Apple的一个目标，SwiftUI在跨设备展示的能力上是一把大杀器； 其次SwiftUI还使自动布局和暗模式等功能变得非常容易，降低了适配等开发成本，对不需要太多元素的小部件来说，SwiftUI重点关注布局的特点无疑是最合适的； 从另一方面来讲，只有使用 SwiftUI 才能达到我们上边说的对于 Widget 的限制。如果可以使用 Objective-C UIKit 的话，我们强大的开发者可能会想出无数的黑科技来忽略Apple真的小部件的限制。比如开发无法使用 UIViewRepresentable 来桥接 UIKit； 最后Apple也夹带了自己的私心，Apple今年已经将 Swift 语言和 SwiftUI 的重要程度提升到了一个新的高度，Swift已经可以独立于Foundtion框架，那么对应的SwiftUI也应该不依赖于UIKit框架了，强行使用SwiftUI可以使开发人员尽可能容易地将其学习其内容并应用于iOS，iPadOS和macOS， 毕竟5月份卡位第20位Objective-C在6月份已经跌出了前20 这里要重点说明一下，Widget只要使用任何 UIKit 的元素就会直接 Crash 二、将小部件目标添加到您的应用 窗口小部件扩展模板提供了创建窗口小部件的起点。单个小部件扩展可以包含多种小部件。例如，一个体育应用程序可能有一个显示团队信息的小部件，另一个显示游戏时间表的小部件。一个小部件扩展可以包含两个小部件。尽管建议将所有窗口小部件包含在一个窗口小部件扩展中，但如有必要，可以添加多个扩展。 在Xcode中打开您的应用程序项目，然后选择“文件”&amp;gt;“新建”&amp;gt;“目标”。 从“应用程序扩展”组中，选择“窗口小部件扩展”，然后单击“下一步”。 输入您的包名。 如果窗口小部件提供了用户可配置的属性，请选中Include Configuration Intent复选框。 单击完成。 重点：小部件不仅支持Swift项目，同样也支持Objective-C项目，OC小伙伴不用担心啦 创建完小部件之后，我们会多出一个SmileEverydayWidget.swift文件，这已经是一个可以run起来的小部件了，因为我们接下来要逐个方法来分析，所以先将文件全文展示如下 // // SmileEverydayWidget.swift // SmileEverydayWidget // // Created by steve on 2020/8/28. // import WidgetKit import SwiftUI struct Provider: TimelineProvider { public typealias Entry = SimpleEntry public func snapshot(with context: Context, completion: @escaping (SimpleEntry) -&amp;gt; ()) { let entry = SimpleEntry(date: Date()) completion(entry) } public func timeline(with context: Context, completion: @escaping (Timeline&amp;lt;Entry&amp;gt;) -&amp;gt; ()) { var entries: [SimpleEntry] = [] // Generate a timeline consisting of five entries an hour apart, starting from the current date. let currentDate = Date() for hourOffset in 0 ..&amp;lt; 5 { let entryDate = Calendar.current.date(byAdding: .hour, value: hourOffset, to: currentDate)! let entry = SimpleEntry(date: entryDate) entries.append(entry) } let timeline = Timeline(entries: entries, policy: .atEnd) completion(timeline) } } struct SimpleEntry: TimelineEntry { public let date: Date } struct PlaceholderView : View { var body: some View { Text(&quot;Placeholder View&quot;) } } struct SmileEverydayWidgetEntryView : View { var entry: Provider.Entry var body: some View { Text(entry.date, style: .time) } } @main struct SmileEverydayWidget: Widget { private let kind: String = &quot;SmileEverydayWidget&quot; public var body: some WidgetConfiguration { StaticConfiguration(kind: kind, provider: Provider(), placeholder: PlaceholderView()) { entry in SmileEverydayWidgetEntryView(entry: entry) } .configurationDisplayName(&quot;My Widget&quot;) .description(&quot;This is an example widget.&quot;) } } struct SmileEverydayWidget_Previews: PreviewProvider { static var previews: some View { /*@START_MENU_TOKEN@*/Text(&quot;Hello, World!&quot;)/*@END_MENU_TOKEN@*/ } } 这里的概念和代码比较多，接下来我们一个一个来解释 三、Widget API 首先我们从带有main字段的方法来说起， @main struct SmileEverydayWidget: Widget { private let kind: String = &quot;com.steve.liu.smileEverydayWidget&quot; public var body: some WidgetConfiguration { StaticConfiguration(kind: kind, provider: Provider(), placeholder: PlaceholderView()) { entry in SmileEverydayWidgetEntryView(entry: entry) } .configurationDisplayName(&quot;My Widget&quot;) .description(&quot;This is an example widget.&quot;) .supportedFamilies([.systemSmall, .systemMedium, .systemLarge]) } } 大家都知道带有main标识的方法都是程序的入口 这段代码使用SwiftUI声明了一个名为SmileEverydayWidget的小部件，其中StaticConfiguration是小部件的初始化方法，它有几个参数： kind provider placeholder 其中 kind是标识小部件的字符串,并且应描述小部件所代表的内容。即小部件的包名 provider为时间线提供者 PlaceholderView为占位视图 同时也提供了一些方法，例如 configurationDisplayName()设置小部件显示的名称 description()设置小部件的描述 supportedFamilies()设置小部件支持的尺寸 这里有一个重点，为了使某个应用程序的窗口小部件出现在窗口小部件库中，用户必须在安装该应用程序后至少启动一次包含该窗口小部件的应用程序。 四、WidgetEntryView WidgetEntryView就是使用SwiftUI布局的小部件视图 struct SmileEverydayWidgetEntryView : View { var entry: Provider.Entry var body: some View { Text(entry.date, style: .time) } } 例如这个小部件视图就简单的展示了当前的时间 接下来我们可以将默认的布局更改为我们自己想要的布局，例如我在设置了显示文本的字体和小部件的背景图 struct SmileEverydaWidgetEntryView : View { var entry: Provider.Entry var body: some View { return Text(entry.message) .background(Image(entry.backgroundImageStr)) .font(.callout) } } 五、PlaceholderView 每种小部件都需要提供占位符UI。 占位符UI是窗口小部件的默认内容。 它应该代表您的小部件类型，但仅此而已。 此用户界面中不应有任何用户数据。 想象一下 如果在用户的主屏幕上出现如下的场景，那么你的小部件离被移除可能已经不远了 六、TimelineEntry 我们知道小部件是按照时间线来展示的，TimelineEntry时间线上的一个个条目 struct SimpleEntry: TimelineEntry { public let date: Date } TimelineEntry有一个必须有的属性就是date，也就是这个条目在时间线上的具体时间 另外开发者可以在TimelineEntry里自定义各种属性，用来给小部件视图提供数据 例如我在TimelineEntry里自定义了message 和backgroundImageStr 属性，用来显示小部件上的文字和背景图片 struct SimpleEntry: TimelineEntry { public let date: Date public let message: String public let backgroundImageStr : String } 七、TimelineProvider TimelineProvider 是一个提供了上述我们所说的TimelineEntry集合的对象 我们来看下具体的代码： struct Provider: TimelineProvider { public typealias Entry = SimpleEntry public func snapshot(with context: Context, completion: @escaping (SimpleEntry) -&amp;gt; ()) { let entry = SimpleEntry(date: Date()) completion(entry) } public func timeline(with context: Context, completion: @escaping (Timeline&amp;lt;Entry&amp;gt;) -&amp;gt; ()) { var entries: [SimpleEntry] = [] // Generate a timeline consisting of five entries an hour apart, starting from the current date. let currentDate = Date() for hourOffset in 0 ..&amp;lt; 5 { let entryDate = Calendar.current.date(byAdding: .hour, value: hourOffset, to: currentDate)! let entry = SimpleEntry(date: entryDate) entries.append(entry) } let timeline = Timeline(entries: entries, policy: .atEnd) completion(timeline) } } 其中包含两个方法 snapshot() timeline() 1、snapshot 快照 为了在小部件库中显示小部件，WidgetKit 要求提供者提供预览快照， 即snapshot()，这个方法里主要提供了一些示例数据，最好是真实数据，用于时间线不能展示的时候展示给用户 需要说明的是，快照是系统需要快速显示单个条目的位置。 因此，您的扩展程序必须尽快返回视图，因为这样做时，用户会在iOS上漂亮的Widget Gallery中看到真正的Widget。 这不是我们在设计时必须提供的屏幕截图或图像。这是用户在iOS，iPadOS和macOS上真正的小部件体验。 在大多数情况下，时间轴的第一个条目和快照可以作为同一条目返回，因此，在“小工具库”中看到的就是用户将其添加到设备中时得到的内容。 例如我们在Widget Gallery中添加电池小部件时，小部件此时在Widget Gallery中展示的就是当前设备电池信息的实时数据的快照，而不是一些虚假的数据，这个时候小部件的数据是什么样子，用户添加到主屏幕上之后小部件的数据就是什么样子，从而提高用户的体验。 对比 小部件里有两个比较类似的概念，PlaceholderView和snapshot，都是一种占位解决方案，不同的是PlaceholderView是在主屏幕上无法快速获取数据时的一种占位视图，不至于显示loading或者白屏给用户看；而snapshot主要用于Widget Gallery中，用来提高用户体验的，一般来说，snapshot 就是时间线的第一帧 2、timeline 在请求初始快照后，WidgetKit调用timeline以请求提供者的常规时间轴。时间轴由一个或多个时间轴条目TimelineEntry以及一个重载策略ReloadPolicy组成，该重载策略通知WidgetKit何时请求后续时间轴。 关于重载策略，提供了以下几种策略 atEnd: 是指 Timeline 执行到最后一个时间片的时候再刷新。 atAfter: 是指在某个时间以后有规律的刷新 never：是指以后不需要刷新了。什么时候需要重新刷新需要 App 重新告知 Widget 根据上边的分析，我们可以将TimelineProvider 改造如下 struct Provider: TimelineProvider { public typealias Entry = SimpleEntry public func snapshot(with context: Context, completion: @escaping (SimpleEntry) -&amp;gt; ()) { let date = Date() let message = &quot;蒹葭苍苍，白露为霜。所谓伊人，在水一方。&quot; let backgroundImageStr = &quot;bg7&quot; let entry = SimpleEntry(date: date, message: message, backgroundImageStr: backgroundImageStr) completion(entry) } public func timeline(with context: Context, completion: @escaping (Timeline&amp;lt;Entry&amp;gt;) -&amp;gt; ()) { var entries: [SimpleEntry] = [] var currentDate = Date() var nextUpdateDate = Calendar.current.date(byAdding: .second, value: 3, to: currentDate)! let message = &quot;蒹葭苍苍，白露为霜。所谓伊人，在水一方。\n溯洄从之，道阻且长；溯游从之，宛在水中央。\n蒹葭凄凄，白露未晞。所谓伊人，在水之湄。&quot; let backgroundImageStr = &quot;bg&quot; let formatter = DateFormatter() formatter.dateFormat = &quot;yyyy-MM-dd HH:mm:ss&quot; var currentDateStr = &quot;&quot; var nextUpdateDateStr = &quot;&quot; let longUuid = UUID().uuidString let range: Range = longUuid.range(of: &quot;-&quot;)! let location: Int = longUuid.distance(from: longUuid.startIndex, to: range.lowerBound) let uuid = longUuid.prefix(location) for i in 1 ..&amp;lt; 10 { var msg = &quot;&quot; currentDate = nextUpdateDate; nextUpdateDate = Calendar.current.date(byAdding: .second, value: 3, to: currentDate)! currentDateStr = formatter.string(from: currentDate) nextUpdateDateStr = formatter.string(from: nextUpdateDate) msg.append(message) msg.append(&quot;\n时间轴ID &quot; + uuid); msg.append(&quot;\n时间轴第&quot; + String(i+1) + &quot;个视图&quot;) msg.append(&quot;\n本次视图开始时间 &quot; + currentDateStr) msg.append(&quot;\n下次视图开始时间 &quot; + nextUpdateDateStr) let entry = SimpleEntry(date: currentDate, message: msg, backgroundImageStr: backgroundImageStr+String(i)) entries.append(entry) print(String(i)) } let timeline = Timeline(entries: entries, policy: .atEnd) completion(timeline) } } 这段代码里我们提供了一个古诗词的快照 并生成了一个时间线，其中时间线里包含了10个entry，且每个entry 间隔10s entry文本拼接显示了 展示文本（诗经） 时间轴ID 本次视图开始时间 下次视图开始时间 下边我们来看一下真实run出来的效果 到此为止我们就有了一个可以在主屏幕上展示的小部件了 并且能根据时间线展示不同的视图了。 七、Reload Timeline 使小部件保持最新 为了使我们的小部件能随时提供最新的，而不是过期的信息，我们需要不时的对小部件进行更新。 我们已经知道了小部件的本质是一系列的视图堆叠，那么更新小部件就是更新这些视图。 比如一个有三个视图的小部件，预测了现在和未来3小时的天气预报，这个小部件显示步骤如下： 但是有一个很重要的问题就是时间线是我们预测出来的，是预测就会有偏差。比如天气预报，预报2小时后有雨，但是随着天气的变化，2小时后变成晴天了，这个时候我们如果不更新小部件上的时间线，就会在2小时后给用户提供错误的信息。 为此我们需要在有信息变化的时候重新显示新的视图，如下图： 为了是我们的小部件信息准确无误，首先我们需要了解下小部件是如何刷新的 很不幸，Widget 的刷新完全由 WidgetCenter控制。开发者无法通过任何 API 去主动刷新 Widget 的页面，只能告知 WidgetCenter，Timeline 需要刷新了 所以我们不能直接刷新小部件的视图，而是要通过生成一个新的时间线来替换旧的时间线，Reload Timeline 并不是直接刷新 Widget，而是 WidgetCenter 重新向 Widget 请求下一阶段的数据。 其中Reload Timeline分为两种方式 System Reloads App Reloads 1、System Reloads 这个行为由系统主动发起，会调用一次 Reload Timeline 向 Widget 请求下一阶段刷新的数据。系统除了会按时发起 System Reloads 之外，还会动态决策每个不同的 TimeLine 的 System Reloads 的频次。比如被点击次数很大程度上直接决定了 System Reloads 的频率，点击率越高，更新频次越快，当然还有一些由于设备环境变化触发的行为也会触发 System Reloads，比如设备时间进行了变更。 很显然这种方案不能很好的解决我们上边的问题 2、App Reloads 这种行为指的是App主动通知小部件，你需要更新信息了。这里边根据App的当前的前后台状态又分为两种方式 应用在前台运行 应用在后台运行 当应用在前台运行的时候，App 可以直接使用WidgetCenter的 API 来 Reload Timeline；而当应用处于后台时，可以使用后台推送（Background Notification）来 Reload Timeline。 除了这些，给Timeline设定合适的刷新策略也是很重要的手段 合理的组合使用这些刷新机制，能够极大的提高Widget信息的准确性 八、交互 前边我们说过，widget和app交互有两种方式SwiftUI widgetURL API和SwiftUI Link API 这两种方式的本质都是URL Schemes，只要监听SceneDelegate的scene:openURLContexts:就可以了 由于Schemes大家都太熟悉了，关于如何高效快速准确的传递参数，这里就不展开讲了。 九、设计漂亮的小部件 如果你已经看到了这里，并且已经理解了上述的讲解，你已经具备了开发小部件的能力。 那么有哪些关键点能给自己的小部件锦上添花呢？ 去除额外的App信息：系统会在小部件下方自动显示你的应用名称，因此你无需在内容中重复App的名称，Icon，而是要通过颜色，布局和图像来联系您的App 简洁的描述。小部件库中显示的描述可以帮助人们理解每个小部件的功能。从动作动词开始描述通常效果很好；例如，“查看当前天气状况和位置预测”或“跟踪即将举行的活动和会议”。避免包含不必要的短语来引用窗口小部件本身，例如“此窗口小部件显示…”，“使用此窗口小部件…”或“添加此窗口小部件”。 舒适的信息密度：一览无余。当内容显得稀疏时，小部件可能看起来是多余的；当内容太密集时，小部件将无法浏览。如果要包含很多信息，请避免让小部件成为难以解析的项的拼贴。寻求整理内容的方法，以便人们可以立即掌握关键部分，并以更长的时间查看相关细节。您可能还考虑创建一个较大的小部件，并寻找可以用图形替换文本而又不会失去清晰度的位置。 明智地使用颜色：丰富，美丽的色彩吸引眼球，但它们绝不能阻止人们一眼就吸收小部件的信息。使用颜色可以增强小部件的外观，而不会与小部件的内容竞争。 使用系统字体，支持系统功能：例如 支持黑暗模式；使用SF Pro和使用系统字体；文本可缩放。 设计一个真实的预览以显示在小部件库中：突出显示小部件的外观和功能可帮助人们做出明智的决定，并鼓励他们添加小部件。您可以在小部件预览中显示真实数据，但是如果数据生成或加载所需的时间太长，请显示真实的模拟数据。 设计占位符内容，以帮助人们识别您的小部件。小部件在加载数据时显示占位符内容。通过将UI的静态部分与代表实际内容的半透明形状结合起来，可以创建有效的预览。例如，您可以使用不同宽度的矩形来建议文本行，并使用圆环或正方形代替字形和图像。 图片适配屏幕尺寸：确保图片在大部件和小部件下都不会压缩 十围之木，始生如蘖 简单的总结一下 一个优秀的小部件是完全可以提高用户体验，成为很好的流量入口，给App带来巨大的商业价值。 但是要设计一个优秀的小部件也并非易事。 本文抛砖引玉，希望大家能设计出更多优秀的小部件。 本次的Widget指北到这里就结束了，万字不易，多多传播。 喜欢我你就关注我, 有话说你就评论我, 都不干你就点个赞 Demo SmileEveryday 参考 Meet WidgetKit Human Interface Guidelines Creating a Widget Extension Keeping a Widget Up To Date Apple Widget：下一个顶级流量入口？</summary></entry><entry><title type="html">Xcode11提前适配iOS14 IDFA，并打包上线</title><link href="http://localhost:4000/Xcode11%E6%8F%90%E5%89%8D%E9%80%82%E9%85%8DiOS14IDFA%E5%B9%B6%E4%B8%8A%E7%BA%BF/" rel="alternate" type="text/html" title="Xcode11提前适配iOS14 IDFA，并打包上线" /><published>2020-08-04T00:00:00+08:00</published><updated>2020-08-04T00:00:00+08:00</updated><id>http://localhost:4000/Xcode11%E6%8F%90%E5%89%8D%E9%80%82%E9%85%8DiOS14IDFA%E5%B9%B6%E4%B8%8A%E7%BA%BF</id><content type="html" xml:base="http://localhost:4000/Xcode11%E6%8F%90%E5%89%8D%E9%80%82%E9%85%8DiOS14IDFA%E5%B9%B6%E4%B8%8A%E7%BA%BF/">&lt;p&gt;背景：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;为了防止用户在升级到iOS14的时候出现不兼容的情况，也为了提升用户升级系统的平滑感。&lt;/p&gt;

  &lt;p&gt;同时为了统计，广告，归因的一系列功能的在系统升级时不出现空窗期。&lt;/p&gt;

  &lt;p&gt;开发者不能等到iOS发布，以及Xcode12发布之后再去针对App进行优化或者强制要求更新。&lt;/p&gt;

  &lt;p&gt;针对Xcode12 Beta版不能打包上架，以及Xcode11无法使用AppTrackingTransparency系统库的问题，帮助开发者提前适配iOS 14 IDFA，是本文要解决的问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;一变化&quot;&gt;一、变化&lt;/h3&gt;

&lt;p&gt;iOS 14 Apple对隐私增加了更强的保护，首当其冲受影响的就是IDFA。&lt;/p&gt;

&lt;p&gt;在LAT（Limit Ad Tracking）的机制下又增加ATT（AppTrackingTransparency）机制。&lt;/p&gt;

&lt;h3 id=&quot;二att机制特点&quot;&gt;二、ATT机制特点&lt;/h3&gt;

&lt;h4 id=&quot;1前置于lat机制当没有att的时候lat不生效&quot;&gt;1、前置于LAT机制，当没有ATT的时候，LAT不生效&lt;/h4&gt;

&lt;p&gt;在iOS 14的系统上如果不使用ATT向用户请求IDFA的使用权限的话，在设置里也不会有，即不主动请求权限，用户也没办法主动开启&lt;/p&gt;

&lt;h4 id=&quot;2可以细化到针对不同app启用不同的设置&quot;&gt;2、可以细化到针对不同App启用不同的设置&lt;/h4&gt;

&lt;p&gt;之前LAT是针对系统的，ATT可以在总开关之外，单独对App进行设置。以前一个App种树，大家乘凉的场景要消失了，现在需要每个App都要向用户请求IDFA权限&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;../images/xcode11idfa/4.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;3需要和定位相机等权限一样在infoplits中声明权限并说明使用目的&quot;&gt;3、需要和定位相机等权限一样，在info.plits中声明权限，并说明使用目的&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;../images/xcode11idfa/5.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;三使用att&quot;&gt;三、使用ATT&lt;/h3&gt;

&lt;h4 id=&quot;1获取当前app用户授权状态&quot;&gt;1、获取当前App，用户授权状态&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+ requestTrackingAuthorizationWithCompletionHandler:&lt;/code&gt;
The request for user authorization to access app-related data.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ATTrackingManagerAuthorizationStatus states = [ATTrackingManager trackingAuthorizationStatus];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;2判断用户的授权状态&quot;&gt;2、判断用户的授权状态&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;trackingAuthorizationStatus&lt;/code&gt; The authorization status that is current for the calling application.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef NS_ENUM(NSUInteger, ATTrackingManagerAuthorizationStatus) {
    ATTrackingManagerAuthorizationStatusNotDetermined = 0,
    ATTrackingManagerAuthorizationStatusRestricted,
    ATTrackingManagerAuthorizationStatusDenied,
    ATTrackingManagerAuthorizationStatusAuthorized
} NS_SWIFT_NAME(ATTrackingManager.AuthorizationStatus) API_AVAILABLE(ios(14), macosx(10.16), tvos(14));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ATTrackingManagerAuthorizationStatusNotDetermined&lt;/code&gt; 未向用户请求授权&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ATTrackingManagerAuthorizationStatusRestricted&lt;/code&gt; 用户在系统级别开启了限制广告追踪&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ATTrackingManagerAuthorizationStatusDenied&lt;/code&gt; 用户拒绝向App授权&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ATTrackingManagerAuthorizationStatusAuthorized&lt;/code&gt; 用户同意向App授权&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;3向用户请求授权&quot;&gt;3、向用户请求授权&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;当&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;states&lt;/code&gt;为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ATTrackingManagerAuthorizationStatusAuthorized&lt;/code&gt; 可以使用IDFA&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;states&lt;/code&gt;为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ATTrackingManagerAuthorizationStatusRestricted&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ATTrackingManagerAuthorizationStatusDenied&lt;/code&gt;时需要向用户弹窗请求用户主动去设置里关闭&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;限制广告追踪&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;../images/xcode11idfa/6.png&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;当&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;states&lt;/code&gt;为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ATTrackingManagerAuthorizationStatusNotDetermined&lt;/code&gt; 向用户发起请求授权&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;../images/xcode11idfa/7.png&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;4全部流程代码&quot;&gt;4、全部流程代码&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// iOS 14请求idfa权限
if (@available(iOS 14.0, *)) {
    ATTrackingManagerAuthorizationStatus states = [ATTrackingManager trackingAuthorizationStatus];
    if (states == ATTrackingManagerAuthorizationStatusNotDetermined) {
        // 未提示用户
        
        [ATTrackingManager requestTrackingAuthorizationWithCompletionHandler:^(ATTrackingManagerAuthorizationStatus status) {
            dispatch_async(dispatch_get_main_queue(), ^{
                // 获取到权限后，依然使用老方法获取idfa
                if (status == ATTrackingManagerAuthorizationStatusAuthorized) {
                    
                }
                else {
                    UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;&quot; message:XYLocalizedString(@&quot;请在设置-隐私-Tracking中允许App请求跟踪&quot;) preferredStyle:UIAlertControllerStyleAlert];
                    UIAlertAction *action2 = [UIAlertAction actionWithTitle:XYLocalizedString(@&quot;确认&quot;) style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {}];
                    [alert addAction:action2];
                    [self presentViewController:alert animated:YES completion:nil];
                }
            });
        }];
    }
    else if (states == ATTrackingManagerAuthorizationStatusRestricted) {
        // 限制使用
        UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;&quot; message:XYLocalizedString(@&quot;请在设置-隐私-Tracking中允许App请求跟踪&quot;) preferredStyle:UIAlertControllerStyleAlert];
        UIAlertAction *action2 = [UIAlertAction actionWithTitle:XYLocalizedString(@&quot;确认&quot;) style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {}];
        [alert addAction:action2];
        [self presentViewController:alert animated:YES completion:nil];
    }
    else if (states == ATTrackingManagerAuthorizationStatusDenied) {
        // 拒绝
        UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;&quot; message:XYLocalizedString(@&quot;请在设置-隐私-Tracking中允许App请求跟踪&quot;) preferredStyle:UIAlertControllerStyleAlert];
        UIAlertAction *action2 = [UIAlertAction actionWithTitle:XYLocalizedString(@&quot;确认&quot;) style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {}];
        [alert addAction:action2];
        [self presentViewController:alert animated:YES completion:nil];
    }
    else if (states == ATTrackingManagerAuthorizationStatusAuthorized) {
        // 可以使用IDFA
    }
}
// iOS 14以下请求idfa权限
else {
    BOOL b = [XYSystemUtil canUseIDFA];
    if (!b) {
        UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;&quot; message:XYLocalizedString(@&quot;请在设置-隐私-广告中允许App请求跟踪&quot;) preferredStyle:UIAlertControllerStyleAlert];
        UIAlertAction *action2 = [UIAlertAction actionWithTitle:XYLocalizedString(@&quot;确认&quot;) style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {}];
        [alert addAction:action2];
        [self presentViewController:alert animated:YES completion:nil];
    }
    else {
    	// 可以使用IDFA
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;四测试以及上架重点来了&quot;&gt;四、测试以及上架（重点来了）&lt;/h3&gt;

&lt;p&gt;矛盾点&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Xcode11没有iOS14系统库，Xcode12 Beta版无法上架&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;针对iOS14和以下系统单独做适配&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;针对上架，笔者测试了三种情况&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用Xcode12 Beta编译打包直接上传，会直接无法上传，提示&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;ERROR ITMS-90534: “Invalid Toolchain. Your app was built with an unsupported SDK or version of Xcode. If you plan to submit this build to the App Store, make sure you are using the versions listed in https://help.apple.com/xcode/mac/current/#/devf16aefe3b or later.”&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用Xcode12 Beta打包，并修改ipa中info.plist里的Xcode版本号，可以正常上传到Connect，但是提审之后会收到邮件&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;The status of your app has changed to Invalid Binary.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用Xcode11 Link iOS14系统库，然后打包上传，在机审之后会提示&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;此构建版本无效。ITMS-90562: Invalid Bundle - One or more dynamic libraries that are referenced by your app are not present in the dylib search path.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;最后解决方案是&quot;&gt;最后解决方案是&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;IDE层面，Xcode11 Link Xcode12 Beta版中的iOS14系统库&lt;/li&gt;
  &lt;li&gt;编译打包层面，代码中不强制Link &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AppTrackingTransparency.framework&lt;/code&gt;系统库&lt;/li&gt;
  &lt;li&gt;代码编写层面，使用动态Link系统库，以及runtime调用对应的方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;第一步&quot;&gt;第一步&lt;/h4&gt;

&lt;p&gt;为了能使用Xcode11来测试和调试ATT，我们需要将Xcode12 Beta版中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AppTrackingTransparency.framework&lt;/code&gt;copy到Xcode11同目录下&lt;/p&gt;

&lt;p&gt;Xcode12 Beta版中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AppTrackingTransparency.framework&lt;/code&gt;的路径如下&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;真机&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/Applications/Xcode-beta.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/System/Library/Frameworks/AppTrackingTransparency.framework&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;模拟器&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/Applications/Xcode-beta.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/AppTrackingTransparency.framework&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;完成此步之后，即可在测试和调试的时候使用Xcode11使用ATT&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;第二步&quot;&gt;第二步&lt;/h4&gt;

&lt;p&gt;因在Xcode11上使用iOS13 SDK 来Deployment Target，会导致在低版本手机上无法Link高版本系统库，从而Crash，报错&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;dyld: Library not loaded: /System/Library/Frameworks/AppTrackingTransparency.framework/AppTrackingTransparency&lt;/p&gt;

  &lt;p&gt;Reason: image not found&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以需要&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;动态Link系统库，以及runtime调用对应的方法&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;先创建对应的Runtime反射类&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XYATTrackingManager&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;头文件&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XYATTrackingManager.h&lt;/code&gt;完全copy自&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ATTrackingManager.h&lt;/code&gt;,并将类名由&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ATTrackingManager&lt;/code&gt;改为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XYATTrackingManager&lt;/code&gt;，代码如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;
#import &amp;lt;os/availability.h&amp;gt;

typedef NS_ENUM(NSUInteger, ATTrackingManagerAuthorizationStatus) {
    ATTrackingManagerAuthorizationStatusNotDetermined = 0,
    ATTrackingManagerAuthorizationStatusRestricted,
    ATTrackingManagerAuthorizationStatusDenied,
    ATTrackingManagerAuthorizationStatusAuthorized
} NS_SWIFT_NAME(ATTrackingManager.AuthorizationStatus) API_AVAILABLE(ios(14), macosx(10.16), tvos(14));

API_AVAILABLE(ios(14), macosx(10.16), tvos(14))
@interface XYATTrackingManager : NSObject

/*!
 * @property trackingAuthorizationStatus
 *
 * @abstract
 * Returns information about your application’s tracking authorization status.
 * Users are able to grant or deny developers tracking privileges on a per-app basis.
 * Application developers must call `requestTrackingAuthorizationWithCompletionHandler:` for the ability to track users.
 *
 * @result
 * The current authorization status. If the user has not yet been prompted to approve access, the return value will either be
 * ATTrackingManagerAuthorizationStatusNotDetermined, or ATTrackingManagerAuthorizationStatusRestricted if this value is managed.
 * Once the user has been prompted, the return value will be either ATTrackingManagerAuthorizationStatusDenied or ATTrackingManagerAuthorizationStatusAuthorized.
 */
@property (class, nonatomic, readonly, assign) ATTrackingManagerAuthorizationStatus trackingAuthorizationStatus;

/*!
 * @method requestTrackingAuthorizationWithCompletionHandler:completion:
 *
 * @abstract
 * Request user tracking authorization with a completion handler returning the user's authorization status.
 * Users are able to grant or deny developers tracking privileges on a per-app basis.
 * This method allows developers to determine if access has been granted. On first use, this method will prompt the user to grant or deny access.
 *
 * The completion handler will be called with the result of the user's decision for granting or denying permission to use application tracking.
 * The completion handler will be called immediately if access to request authorization is restricted.
 */
+ (void)requestTrackingAuthorizationWithCompletionHandler:(void(^)(ATTrackingManagerAuthorizationStatus status))completion;

// This class, at this time, should not be instantiated.
+ (instancetype)new NS_UNAVAILABLE;

// This class, at this time, should not be instantiated.
- (instancetype)init NS_UNAVAILABLE;

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;
实现文件&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XYATTrackingManager.m&lt;/code&gt;需要做两步处理&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;动态Link AppTrackingTransparency.framework库&lt;/li&gt;
  &lt;li&gt;Runtime调用 AppTrackingTransparency.framework库&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实现代码如下&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &quot;XYATTrackingManager.h&quot;
#import &amp;lt;objc/runtime.h&amp;gt;
#import &amp;lt;objc/message.h&amp;gt;

@implementation XYATTrackingManager

+ (ATTrackingManagerAuthorizationStatus)trackingAuthorizationStatus {
    
    Class ATTrackingManager = NSClassFromString(@&quot;ATTrackingManager&quot;);
    if (ATTrackingManager == nil) {
        NSBundle *bundle = [NSBundle bundleWithPath:@&quot;/System/Library/Frameworks/AppTrackingTransparency.framework&quot;];
        [bundle load];
        ATTrackingManager = NSClassFromString(@&quot;ATTrackingManager&quot;);
    }
    ATTrackingManagerAuthorizationStatus returnValue = ((int (*)(id, SEL)) objc_msgSend)(ATTrackingManager, _cmd);
    return returnValue;
}

+ (void)requestTrackingAuthorizationWithCompletionHandler:(void(^)(ATTrackingManagerAuthorizationStatus status))completion {
    Class ATTrackingManager = NSClassFromString(@&quot;ATTrackingManager&quot;);
    if (ATTrackingManager == nil) {
        NSBundle *bundle = [NSBundle bundleWithPath:@&quot;/System/Library/Frameworks/AppTrackingTransparency.framework&quot;];
        [bundle load];
        ATTrackingManager = NSClassFromString(@&quot;ATTrackingManager&quot;);
    }
    ((void (*)(id, SEL, void(^)(ATTrackingManagerAuthorizationStatus status))) objc_msgSend)(ATTrackingManager, _cmd, completion);
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSBundle *bundle = [NSBundle bundleWithPath:@&quot;/System/Library/Frameworks/AppTrackingTransparency.framework&quot;];
[bundle load];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;为动态Link AppTrackingTransparency.framework库&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Class ATTrackingManager = NSClassFromString(@&quot;ATTrackingManager&quot;);
ATTrackingManagerAuthorizationStatus returnValue = ((int (*)(id, SEL)) objc_msgSend)(ATTrackingManager, _cmd);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Class ATTrackingManager = NSClassFromString(@&quot;ATTrackingManager&quot;);
((void (*)(id, SEL, void(^)(ATTrackingManagerAuthorizationStatus status))) objc_msgSend)(ATTrackingManager, _cmd, completion);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;为Runtime反射调用AppTrackingTransparency.framework库&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;第三步&quot;&gt;第三步&lt;/h4&gt;

&lt;p&gt;将代码里使用到的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ATTrackingManager&lt;/code&gt;全部替换为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XYATTrackingManager&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;到此就完成了Xcode11对iOS13 AppTrackingTransparency.framework库的支持，可以打包上架了。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;五最后&quot;&gt;五、最后&lt;/h3&gt;

&lt;p&gt;目前离iOS14正式版发布还有一个多月的时间，可以说时间已经很紧迫了。&lt;/p&gt;

&lt;p&gt;在正式版发布之前提前让自己的App适配ATT并上线发布安装到用户的手机中是一件很有必要的事情&lt;/p&gt;

&lt;p&gt;马上行动起来吧！！！&lt;/p&gt;</content><author><name></name></author><category term="SDK" /><category term="Framework" /><summary type="html">背景： 为了防止用户在升级到iOS14的时候出现不兼容的情况，也为了提升用户升级系统的平滑感。 同时为了统计，广告，归因的一系列功能的在系统升级时不出现空窗期。 开发者不能等到iOS发布，以及Xcode12发布之后再去针对App进行优化或者强制要求更新。 针对Xcode12 Beta版不能打包上架，以及Xcode11无法使用AppTrackingTransparency系统库的问题，帮助开发者提前适配iOS 14 IDFA，是本文要解决的问题。 一、变化 iOS 14 Apple对隐私增加了更强的保护，首当其冲受影响的就是IDFA。 在LAT（Limit Ad Tracking）的机制下又增加ATT（AppTrackingTransparency）机制。 二、ATT机制特点 1、前置于LAT机制，当没有ATT的时候，LAT不生效 在iOS 14的系统上如果不使用ATT向用户请求IDFA的使用权限的话，在设置里也不会有，即不主动请求权限，用户也没办法主动开启 2、可以细化到针对不同App启用不同的设置 之前LAT是针对系统的，ATT可以在总开关之外，单独对App进行设置。以前一个App种树，大家乘凉的场景要消失了，现在需要每个App都要向用户请求IDFA权限 3、需要和定位相机等权限一样，在info.plits中声明权限，并说明使用目的 三、使用ATT 1、获取当前App，用户授权状态 + requestTrackingAuthorizationWithCompletionHandler: The request for user authorization to access app-related data. ATTrackingManagerAuthorizationStatus states = [ATTrackingManager trackingAuthorizationStatus]; 2、判断用户的授权状态 trackingAuthorizationStatus The authorization status that is current for the calling application. typedef NS_ENUM(NSUInteger, ATTrackingManagerAuthorizationStatus) { ATTrackingManagerAuthorizationStatusNotDetermined = 0, ATTrackingManagerAuthorizationStatusRestricted, ATTrackingManagerAuthorizationStatusDenied, ATTrackingManagerAuthorizationStatusAuthorized } NS_SWIFT_NAME(ATTrackingManager.AuthorizationStatus) API_AVAILABLE(ios(14), macosx(10.16), tvos(14)); 其中 ATTrackingManagerAuthorizationStatusNotDetermined 未向用户请求授权 ATTrackingManagerAuthorizationStatusRestricted 用户在系统级别开启了限制广告追踪 ATTrackingManagerAuthorizationStatusDenied 用户拒绝向App授权 ATTrackingManagerAuthorizationStatusAuthorized 用户同意向App授权 3、向用户请求授权 当states为ATTrackingManagerAuthorizationStatusAuthorized 可以使用IDFA 当states为ATTrackingManagerAuthorizationStatusRestricted和ATTrackingManagerAuthorizationStatusDenied时需要向用户弹窗请求用户主动去设置里关闭限制广告追踪 当states为ATTrackingManagerAuthorizationStatusNotDetermined 向用户发起请求授权 4、全部流程代码 // iOS 14请求idfa权限 if (@available(iOS 14.0, *)) { ATTrackingManagerAuthorizationStatus states = [ATTrackingManager trackingAuthorizationStatus]; if (states == ATTrackingManagerAuthorizationStatusNotDetermined) { // 未提示用户 [ATTrackingManager requestTrackingAuthorizationWithCompletionHandler:^(ATTrackingManagerAuthorizationStatus status) { dispatch_async(dispatch_get_main_queue(), ^{ // 获取到权限后，依然使用老方法获取idfa if (status == ATTrackingManagerAuthorizationStatusAuthorized) { } else { UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;&quot; message:XYLocalizedString(@&quot;请在设置-隐私-Tracking中允许App请求跟踪&quot;) preferredStyle:UIAlertControllerStyleAlert]; UIAlertAction *action2 = [UIAlertAction actionWithTitle:XYLocalizedString(@&quot;确认&quot;) style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {}]; [alert addAction:action2]; [self presentViewController:alert animated:YES completion:nil]; } }); }]; } else if (states == ATTrackingManagerAuthorizationStatusRestricted) { // 限制使用 UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;&quot; message:XYLocalizedString(@&quot;请在设置-隐私-Tracking中允许App请求跟踪&quot;) preferredStyle:UIAlertControllerStyleAlert]; UIAlertAction *action2 = [UIAlertAction actionWithTitle:XYLocalizedString(@&quot;确认&quot;) style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {}]; [alert addAction:action2]; [self presentViewController:alert animated:YES completion:nil]; } else if (states == ATTrackingManagerAuthorizationStatusDenied) { // 拒绝 UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;&quot; message:XYLocalizedString(@&quot;请在设置-隐私-Tracking中允许App请求跟踪&quot;) preferredStyle:UIAlertControllerStyleAlert]; UIAlertAction *action2 = [UIAlertAction actionWithTitle:XYLocalizedString(@&quot;确认&quot;) style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {}]; [alert addAction:action2]; [self presentViewController:alert animated:YES completion:nil]; } else if (states == ATTrackingManagerAuthorizationStatusAuthorized) { // 可以使用IDFA } } // iOS 14以下请求idfa权限 else { BOOL b = [XYSystemUtil canUseIDFA]; if (!b) { UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;&quot; message:XYLocalizedString(@&quot;请在设置-隐私-广告中允许App请求跟踪&quot;) preferredStyle:UIAlertControllerStyleAlert]; UIAlertAction *action2 = [UIAlertAction actionWithTitle:XYLocalizedString(@&quot;确认&quot;) style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {}]; [alert addAction:action2]; [self presentViewController:alert animated:YES completion:nil]; } else { // 可以使用IDFA } } 四、测试以及上架（重点来了） 矛盾点 Xcode11没有iOS14系统库，Xcode12 Beta版无法上架 针对iOS14和以下系统单独做适配 针对上架，笔者测试了三种情况 使用Xcode12 Beta编译打包直接上传，会直接无法上传，提示 ERROR ITMS-90534: “Invalid Toolchain. Your app was built with an unsupported SDK or version of Xcode. If you plan to submit this build to the App Store, make sure you are using the versions listed in https://help.apple.com/xcode/mac/current/#/devf16aefe3b or later.” 使用Xcode12 Beta打包，并修改ipa中info.plist里的Xcode版本号，可以正常上传到Connect，但是提审之后会收到邮件 The status of your app has changed to Invalid Binary. 使用Xcode11 Link iOS14系统库，然后打包上传，在机审之后会提示 此构建版本无效。ITMS-90562: Invalid Bundle - One or more dynamic libraries that are referenced by your app are not present in the dylib search path. 最后解决方案是 IDE层面，Xcode11 Link Xcode12 Beta版中的iOS14系统库 编译打包层面，代码中不强制Link AppTrackingTransparency.framework系统库 代码编写层面，使用动态Link系统库，以及runtime调用对应的方法 第一步 为了能使用Xcode11来测试和调试ATT，我们需要将Xcode12 Beta版中的AppTrackingTransparency.frameworkcopy到Xcode11同目录下 Xcode12 Beta版中的AppTrackingTransparency.framework的路径如下 真机 /Applications/Xcode-beta.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/System/Library/Frameworks/AppTrackingTransparency.framework 模拟器 /Applications/Xcode-beta.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/AppTrackingTransparency.framework 完成此步之后，即可在测试和调试的时候使用Xcode11使用ATT 第二步 因在Xcode11上使用iOS13 SDK 来Deployment Target，会导致在低版本手机上无法Link高版本系统库，从而Crash，报错 dyld: Library not loaded: /System/Library/Frameworks/AppTrackingTransparency.framework/AppTrackingTransparency Reason: image not found 所以需要动态Link系统库，以及runtime调用对应的方法 先创建对应的Runtime反射类XYATTrackingManager 头文件XYATTrackingManager.h完全copy自ATTrackingManager.h,并将类名由ATTrackingManager改为XYATTrackingManager，代码如下： #import &amp;lt;Foundation/Foundation.h&amp;gt; #import &amp;lt;os/availability.h&amp;gt; typedef NS_ENUM(NSUInteger, ATTrackingManagerAuthorizationStatus) { ATTrackingManagerAuthorizationStatusNotDetermined = 0, ATTrackingManagerAuthorizationStatusRestricted, ATTrackingManagerAuthorizationStatusDenied, ATTrackingManagerAuthorizationStatusAuthorized } NS_SWIFT_NAME(ATTrackingManager.AuthorizationStatus) API_AVAILABLE(ios(14), macosx(10.16), tvos(14)); API_AVAILABLE(ios(14), macosx(10.16), tvos(14)) @interface XYATTrackingManager : NSObject /*! * @property trackingAuthorizationStatus * * @abstract * Returns information about your application’s tracking authorization status. * Users are able to grant or deny developers tracking privileges on a per-app basis. * Application developers must call `requestTrackingAuthorizationWithCompletionHandler:` for the ability to track users. * * @result * The current authorization status. If the user has not yet been prompted to approve access, the return value will either be * ATTrackingManagerAuthorizationStatusNotDetermined, or ATTrackingManagerAuthorizationStatusRestricted if this value is managed. * Once the user has been prompted, the return value will be either ATTrackingManagerAuthorizationStatusDenied or ATTrackingManagerAuthorizationStatusAuthorized. */ @property (class, nonatomic, readonly, assign) ATTrackingManagerAuthorizationStatus trackingAuthorizationStatus; /*! * @method requestTrackingAuthorizationWithCompletionHandler:completion: * * @abstract * Request user tracking authorization with a completion handler returning the user's authorization status. * Users are able to grant or deny developers tracking privileges on a per-app basis. * This method allows developers to determine if access has been granted. On first use, this method will prompt the user to grant or deny access. * * The completion handler will be called with the result of the user's decision for granting or denying permission to use application tracking. * The completion handler will be called immediately if access to request authorization is restricted. */ + (void)requestTrackingAuthorizationWithCompletionHandler:(void(^)(ATTrackingManagerAuthorizationStatus status))completion; // This class, at this time, should not be instantiated. + (instancetype)new NS_UNAVAILABLE; // This class, at this time, should not be instantiated. - (instancetype)init NS_UNAVAILABLE; @end 实现文件XYATTrackingManager.m需要做两步处理 动态Link AppTrackingTransparency.framework库 Runtime调用 AppTrackingTransparency.framework库 实现代码如下 #import &quot;XYATTrackingManager.h&quot; #import &amp;lt;objc/runtime.h&amp;gt; #import &amp;lt;objc/message.h&amp;gt; @implementation XYATTrackingManager + (ATTrackingManagerAuthorizationStatus)trackingAuthorizationStatus { Class ATTrackingManager = NSClassFromString(@&quot;ATTrackingManager&quot;); if (ATTrackingManager == nil) { NSBundle *bundle = [NSBundle bundleWithPath:@&quot;/System/Library/Frameworks/AppTrackingTransparency.framework&quot;]; [bundle load]; ATTrackingManager = NSClassFromString(@&quot;ATTrackingManager&quot;); } ATTrackingManagerAuthorizationStatus returnValue = ((int (*)(id, SEL)) objc_msgSend)(ATTrackingManager, _cmd); return returnValue; } + (void)requestTrackingAuthorizationWithCompletionHandler:(void(^)(ATTrackingManagerAuthorizationStatus status))completion { Class ATTrackingManager = NSClassFromString(@&quot;ATTrackingManager&quot;); if (ATTrackingManager == nil) { NSBundle *bundle = [NSBundle bundleWithPath:@&quot;/System/Library/Frameworks/AppTrackingTransparency.framework&quot;]; [bundle load]; ATTrackingManager = NSClassFromString(@&quot;ATTrackingManager&quot;); } ((void (*)(id, SEL, void(^)(ATTrackingManagerAuthorizationStatus status))) objc_msgSend)(ATTrackingManager, _cmd, completion); } @end 其中 NSBundle *bundle = [NSBundle bundleWithPath:@&quot;/System/Library/Frameworks/AppTrackingTransparency.framework&quot;]; [bundle load]; 为动态Link AppTrackingTransparency.framework库 Class ATTrackingManager = NSClassFromString(@&quot;ATTrackingManager&quot;); ATTrackingManagerAuthorizationStatus returnValue = ((int (*)(id, SEL)) objc_msgSend)(ATTrackingManager, _cmd); Class ATTrackingManager = NSClassFromString(@&quot;ATTrackingManager&quot;); ((void (*)(id, SEL, void(^)(ATTrackingManagerAuthorizationStatus status))) objc_msgSend)(ATTrackingManager, _cmd, completion); 为Runtime反射调用AppTrackingTransparency.framework库 第三步 将代码里使用到的ATTrackingManager全部替换为XYATTrackingManager 到此就完成了Xcode11对iOS13 AppTrackingTransparency.framework库的支持，可以打包上架了。 五、最后 目前离iOS14正式版发布还有一个多月的时间，可以说时间已经很紧迫了。 在正式版发布之前提前让自己的App适配ATT并上线发布安装到用户的手机中是一件很有必要的事情 马上行动起来吧！！！</summary></entry><entry><title type="html">SDK自动打包</title><link href="http://localhost:4000/SDKAutoArchive/" rel="alternate" type="text/html" title="SDK自动打包" /><published>2017-08-08T00:00:00+08:00</published><updated>2017-08-08T00:00:00+08:00</updated><id>http://localhost:4000/SDKAutoArchive</id><content type="html" xml:base="http://localhost:4000/SDKAutoArchive/">&lt;p&gt;背景：
由于iOS Framework打包出来是分CPU指令集的，所以需要每个CPU指令集都打包一个Framework，然后使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lipo -create&lt;/code&gt;命令将所有CPU指令集合并，才能形成一个兼容所有设备和模拟器的Framework。这样的打包流程复杂而繁琐，对于需要经常打包测试的需求来说明显是不合适的。&lt;/p&gt;

&lt;h3 id=&quot;解决方案&quot;&gt;解决方案&lt;/h3&gt;
&lt;p&gt;使用xcode &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Aggregate&lt;/code&gt;工具中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Run Script&lt;/code&gt;自动进行不同CPU指令集打包，并自动合并所有CPU指令集&lt;/p&gt;

&lt;h3 id=&quot;处理器指令集介绍&quot;&gt;处理器指令集介绍&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;ARM处理器
	- armv7
	- armv7s
 	- arm64&lt;/li&gt;
  &lt;li&gt;Mac处理器
    &lt;ul&gt;
      &lt;li&gt;i386&lt;/li&gt;
      &lt;li&gt;x86_64&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;指令集&lt;/th&gt;
      &lt;th&gt;设备&lt;/th&gt;
      &lt;th&gt;支持设备&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;arm64&lt;/td&gt;
      &lt;td&gt;真机64位&lt;/td&gt;
      &lt;td&gt;iPhone6s、iphone6s plus、iPhone6、iPhone6 plus、iPhone5S、iPad Air、 iPad mini2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;armv7s&lt;/td&gt;
      &lt;td&gt;真机32位&lt;/td&gt;
      &lt;td&gt;iPhone5、iPhone5C、iPad4(iPad with Retina Display)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;armv7&lt;/td&gt;
      &lt;td&gt;真机32位&lt;/td&gt;
      &lt;td&gt;iPhone4、iPhone4S、iPad、iPad2、iPad3(The New iPad)、iPad mini、iPod Touch 3G、iPod Touch4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;i386&lt;/td&gt;
      &lt;td&gt;模拟器32位&lt;/td&gt;
      &lt;td&gt;针对intel通用微处理器32位处理器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;x86_64&lt;/td&gt;
      &lt;td&gt;模拟器64位&lt;/td&gt;
      &lt;td&gt;针对x86架构的64位处理器&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;添加-aggregate&quot;&gt;添加 Aggregate&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;使用Xcode打开打包工程&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;File&lt;/code&gt;→&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;New&lt;/code&gt;→&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Target&lt;/code&gt;→&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cross-platform&lt;/code&gt;→&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Aggregate&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;命名为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AvidlyAdsSDKArchive&lt;/code&gt;(自由命名)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;添加-run-script&quot;&gt;添加 Run Script&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;打开&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AvidlyAdsSDKArchive&lt;/code&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Aggregate &lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BuildPhases&lt;/code&gt;→&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;New&lt;/code&gt;→&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt;→&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cross-platform&lt;/code&gt;→&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;New Run Script Phase&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;打开新建的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Run Script&lt;/code&gt;，在shell中键入打包代码&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;shell编写打包代码&quot;&gt;shell编写打包代码&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 工程名称
# 如果工程名称和Framework的Target名称不一样的 话，要自定义FMKNAME
# 例如: FMK_NAME = &quot;MyFramework&quot;
FMK_NAME=${PROJECT_NAME}

# 工程Info.list路径
InfoPlist=${SRCROOT}/${PROJECT_NAME}/Info.plist

# 工程Version
Version=$(/usr/libexec/PlistBuddy -c &quot;Print CFBundleShortVersionString&quot; $InfoPlist)
Version=${Version//./}

# 工程Build
Build=$(/usr/libexec/PlistBuddy -c &quot;Print CFBundleVersion&quot; $InfoPlist)

# SDK文件夹名称
SDKFilePath=${SRCROOT}/${PROJECT_NAME}_${Version}_${Build}

# 文件路径是否存在
if [ -d &quot;${SDKFilePath}&quot; ]
then
rm -rf &quot;${SDKFilePath}&quot;
fi
mkdir -p &quot;${SDKFilePath}&quot;

# 当前时间
updataDate=`date +%F`

# 将信息写入文件
updataFileName=${SDKFilePath}/version.md
touch ${updataFileName}
echo 版本:${Version} &amp;gt;&amp;gt; ${updataFileName}
echo 编译:${Build} &amp;gt;&amp;gt; ${updataFileName}
echo 时间:${updataDate} &amp;gt;&amp;gt; ${updataFileName}
echo 更新: &amp;gt;&amp;gt; ${updataFileName}

# SDK目录
INSTALL_DIR=${SDKFilePath}/${FMK_NAME}.framework

# Working dir will be deleted after the framework creation.
WRK_DIR=build
DEVICE_DIR=${WRK_DIR}/Release-iphoneos/${FMK_NAME}.framework
SIMULATOR_DIR=${WRK_DIR}/Release-iphonesimulator/${FMK_NAME}.framework

# -configuration ${CONFIGURATION}
# Clean and Building both architectures.
xcodebuild -configuration &quot;Release&quot; -target &quot;${FMK_NAME}&quot; -sdk iphoneos clean build
xcodebuild -configuration &quot;Release&quot; -target &quot;${FMK_NAME}&quot; -sdk iphonesimulator clean build

# Cleaning the oldest.
if [ -d &quot;${INSTALL_DIR}&quot; ]
then
rm -rf &quot;${INSTALL_DIR}&quot;
fi
mkdir -p &quot;${INSTALL_DIR}&quot;
cp -R &quot;${DEVICE_DIR}/&quot; &quot;${INSTALL_DIR}/&quot;

# Uses the Lipo Tool to merge both binary files (i386 + armv6/armv7) into one Universal final product.
lipo -create &quot;${DEVICE_DIR}/${FMK_NAME}&quot; &quot;${SIMULATOR_DIR}/${FMK_NAME}&quot; -output &quot;${INSTALL_DIR}/${FMK_NAME}&quot;
rm -r &quot;${WRK_DIR}&quot;
open &quot;${SRCROOT}&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;2019-6-10-update&quot;&gt;2019-6-10 Update&lt;/h3&gt;

&lt;p&gt;因Xcode11更新Bulid的目录，将Simulator和真机的编译目录修改为同一个地址，之前的脚本对导致出错，下边是修改后的sh脚本&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
# Sets the target folders and the final framework product.
# 如果工程名称和Framework的Target名称不一样的 话，要自定义FMKNAME
# 例如: FMK_NAME = &quot;MyFramework&quot;
FMK_NAME=${PROJECT_NAME}

PROJECT_PATH=$(cd &quot;$(dirname &quot;$0&quot;)&quot;;pwd)

# 工程Info.list路径
InfoPlist=${PROJECT_PATH}/${FMK_NAME}/Info.plist

# 工程Version
Version=$(/usr/libexec/PlistBuddy -c &quot;Print CFBundleShortVersionString&quot; $InfoPlist)
Version=${Version//./}

# 工程Build
Build=$(/usr/libexec/PlistBuddy -c &quot;Print CFBundleVersion&quot; $InfoPlist)

# SDK文件夹名称
SDKFilePath=${PROJECT_PATH}/${FMK_NAME}_${Version}_${Build}

if [ -d &quot;${SDKFilePath}&quot; ]
then
rm -rf &quot;${SDKFilePath}&quot;
fi
mkdir -p &quot;${SDKFilePath}&quot;

updataDate=`date +%F`
#updataMessage=版本:${Version}\\n编译:${Build}\\n时间:${updataDate}\\n更新:

updataFileName=${SDKFilePath}/version.md
touch ${updataFileName}
echo 版本:${Version} &amp;gt;&amp;gt; ${updataFileName}
echo 编译:${Build} &amp;gt;&amp;gt; ${updataFileName}
echo 时间:${updataDate} &amp;gt;&amp;gt; ${updataFileName}
echo 更新: &amp;gt;&amp;gt; ${updataFileName}

# SDK目录
INSTALL_DIR=${SDKFilePath}/${FMK_NAME}.framework

# Working dir will be deleted after the framework creation.
WRK_DIR=build
WRK_DIR_iphone=build_Release-iphoneos
WRK_DIR_iphonesimulator=build_Release-iphonesimulator

DEVICE_DIR=${WRK_DIR}/Release-iphoneos/${FMK_NAME}.framework
SIMULATOR_DIR=${WRK_DIR}/Release-iphonesimulator/${FMK_NAME}.framework

DEVICE_DIR1=${WRK_DIR_iphone}/Release-iphoneos/${FMK_NAME}.framework
SIMULATOR_DIR1=${WRK_DIR_iphonesimulator}/Release-iphonesimulator/${FMK_NAME}.framework

# -configuration ${CONFIGURATION}
# Clean and Building both architectures.
xcodebuild -configuration &quot;Release&quot; -target &quot;${FMK_NAME}&quot; -sdk iphoneos clean build

# Cleaning the oldest.
if [ -d &quot;${DEVICE_DIR1}&quot; ]
then
rm -rf &quot;${DEVICE_DIR1}&quot;
fi
mkdir -p &quot;${DEVICE_DIR1}&quot;
cp -R &quot;${DEVICE_DIR}/&quot; &quot;${DEVICE_DIR1}/&quot;


xcodebuild -configuration &quot;Release&quot; -target &quot;${FMK_NAME}&quot; -sdk iphonesimulator clean build

# Cleaning the oldest.
if [ -d &quot;${SIMULATOR_DIR1}&quot; ]
then
rm -rf &quot;${SIMULATOR_DIR1}&quot;
fi
mkdir -p &quot;${SIMULATOR_DIR1}&quot;
cp -R &quot;${SIMULATOR_DIR}/&quot; &quot;${SIMULATOR_DIR1}/&quot;

# Cleaning the oldest.
if [ -d &quot;${INSTALL_DIR}&quot; ]
then
rm -rf &quot;${INSTALL_DIR}&quot;
fi
mkdir -p &quot;${INSTALL_DIR}&quot;
cp -R &quot;${DEVICE_DIR1}/&quot; &quot;${INSTALL_DIR}/&quot;

# Uses the Lipo Tool to merge both binary files (i386 + armv6/armv7) into one Universal final product.
lipo -create &quot;${DEVICE_DIR1}/${FMK_NAME}&quot; &quot;${SIMULATOR_DIR1}/${FMK_NAME}&quot; -output &quot;${INSTALL_DIR}/${FMK_NAME}&quot;
rm -r &quot;${WRK_DIR}&quot;
rm -r &quot;${WRK_DIR_iphone}&quot;
rm -r &quot;${WRK_DIR_iphonesimulator}&quot;

open &quot;${SRCROOT}&quot;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="SDK" /><category term="Framework" /><summary type="html">背景： 由于iOS Framework打包出来是分CPU指令集的，所以需要每个CPU指令集都打包一个Framework，然后使用lipo -create命令将所有CPU指令集合并，才能形成一个兼容所有设备和模拟器的Framework。这样的打包流程复杂而繁琐，对于需要经常打包测试的需求来说明显是不合适的。 解决方案 使用xcode Aggregate工具中的Run Script自动进行不同CPU指令集打包，并自动合并所有CPU指令集 处理器指令集介绍 ARM处理器 - armv7 - armv7s - arm64 Mac处理器 i386 x86_64 指令集 设备 支持设备</summary></entry><entry><title type="html">CocoaPods托管Framework</title><link href="http://localhost:4000/CocoaPodsHostingFramework/" rel="alternate" type="text/html" title="CocoaPods托管Framework" /><published>2017-06-16T00:00:00+08:00</published><updated>2017-06-16T00:00:00+08:00</updated><id>http://localhost:4000/CocoaPodsHostingFramework</id><content type="html" xml:base="http://localhost:4000/CocoaPodsHostingFramework/">&lt;p&gt;在发布sdk中，需要在CocoaPods上托管Framework&lt;/p&gt;

&lt;h3 id=&quot;安装cocoapods&quot;&gt;安装CocoaPods&lt;/h3&gt;

&lt;p&gt;首先安装CocoaPods，没安装的自行安装&lt;/p&gt;

&lt;h3 id=&quot;处理源码&quot;&gt;处理源码&lt;/h3&gt;
&lt;p&gt;第一步在github上创建源码库（我们的源码是Framework），并把源码push到github上&lt;/p&gt;

&lt;p&gt;github地址：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://github.com/guojunliu/AvidlyAdsSDK.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;podspec文件&quot;&gt;podspec文件&lt;/h3&gt;
&lt;p&gt;第二步,在目录下创建&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.podspec&lt;/code&gt;文件，此处创建的是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AvidlyAdsSDK.podspec&lt;/code&gt;，&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ pod spec create AvidlyAdsSDK
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;用编辑器打开.podspec文件 (我自己用Sublime Text)&lt;/p&gt;

&lt;p&gt;文件内容为&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Pod::Spec.new do |s|
  s.name             = 'AvidlyAdsSDK'
  s.version          = '2.0.20'
  s.summary          = 'Avidly Ad SDK'
  s.description      = &amp;lt;&amp;lt;-DESC
Avidly Ad SDK.
                       DESC

  s.homepage         = 'http://ads-sdk-doc.haloapps.com/docs/show/2'
  s.license          = { :type =&amp;gt; 'MIT', :file =&amp;gt; 'LICENSE' }
  s.author           = { &quot;steve&quot; =&amp;gt; &quot;steve.liu@holaverse.com&quot; }
  s.source           = { :git =&amp;gt; 'https://github.com/guojunliu/AvidlyAdsSDK.git', :tag =&amp;gt; s.version }

  s.ios.deployment_target = '8.0'

  s.source_files = 'Framework/Appnext/include/*', 'Framework/Chance/include/*', 'Framework/Domob/include/*'
  
  s.resources = &quot;Framework/Chance/resource/*&quot;, &quot;Framework/Domob/resource/*&quot;, &quot;Framework/Vungle/resource/*&quot;, &quot;Framework/AvidlyAdsSDK/resource/*&quot;,

  s.public_header_files = 'Framework/Appnext/include/*', 'Framework/Chance/include/*', 'Framework/Domob/include/*'

  s.library = 'sqlite3', 'z'

  s.frameworks = 'QuartzCore', 'MediaPlayer', 'CoreMedia', 'CoreGraphics', 'CFNetwork', 'WebKit', 'WatchConnectivity', 'SystemConfiguration', 'StoreKit', 'Social', 'MessageUI','JavaScriptCore','EventKit','CoreTelephony','AVFoundation','AudioToolbox','AdSupport'

  s.vendored_libraries = &quot;Framework/Appnext/libAppnextLib.a&quot;, &quot;Framework/Appnext/libAppnextSDKCore.a&quot;, &quot;Framework/Chance/libChanceAd_Video.a&quot;, &quot;Framework/Domob/libIndependentVideoSDK.a&quot;

  s.vendored_frameworks = 'Framework/AdColony/AdColony.framework', 'Framework/Mobvista/MVSDK.framework', 'Framework/Mobvista/MVSDKReward.framework', 'Framework/Unity/UnityAds.framework', 'Framework/Vungle/VungleSDK.framework', 'Framework/AvidlyAdsSDK/AvidlyAdsSDK.framework', 'Framework/FBAudienceNetwork/FBAudienceNetwork.framework', 'Framework/GoogleMobileAds/GoogleMobileAds.framework', 'Framework/HolaStatisticalSDK/HolaStatisticalSDK.framework', 'Framework/OneWay/OneWaySDK.framework'
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;字段解释&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;字段&lt;/th&gt;
      &lt;th&gt;解释&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;name&lt;/td&gt;
      &lt;td&gt;名称&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;version&lt;/td&gt;
      &lt;td&gt;版本号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;summary&lt;/td&gt;
      &lt;td&gt;摘要&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;description&lt;/td&gt;
      &lt;td&gt;描述&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;homepage&lt;/td&gt;
      &lt;td&gt;主页&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;license&lt;/td&gt;
      &lt;td&gt;许可证，这个必须要有，且按照上述格式，否则会出错&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;author&lt;/td&gt;
      &lt;td&gt;作者&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;source&lt;/td&gt;
      &lt;td&gt;资源，源码git库&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ios.deployment_target&lt;/td&gt;
      &lt;td&gt;ios 编译版本&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;source_files&lt;/td&gt;
      &lt;td&gt;源文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;resources&lt;/td&gt;
      &lt;td&gt;资源包，比如图片，bundle等&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;public_header_files&lt;/td&gt;
      &lt;td&gt;共用头文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;library&lt;/td&gt;
      &lt;td&gt;依赖的系统tbd库，要去掉&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lib&lt;/code&gt;前缀,例如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libsqlite3.tbd&lt;/code&gt;要写成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sqlite3&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;frameworks&lt;/td&gt;
      &lt;td&gt;依赖的系统Framework&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;vendored_libraries&lt;/td&gt;
      &lt;td&gt;非系统库，如依赖的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.a&lt;/code&gt;第三方静态库。需要按照目录写&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;vendored_frameworks&lt;/td&gt;
      &lt;td&gt;非系统库，如依赖的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.framework&lt;/code&gt;第三方静态库，我们此次托管的是framework，所以也写在这里。需要按照目录写&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;编写完之后需要校验下&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;podspec&lt;/code&gt;文件格式是的正确，Xcode是否能正常编译。使用下面代码&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ pod lib lint
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;出现下面代码表示验证通过&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-&amp;gt; AvidlyAdsSDK (2.0.20)

AvidlyAdsSDK passed validation.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接下来连同&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;podspec文件&lt;/code&gt;一起push到github，由于Cocoapods在自己配置的s.source git中是以版本号检索的，即git的tag，所以我们push之后，别忘记给当次commit打上tag标签，这里打的是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2.0.20&lt;/code&gt;,要和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;podspec文件&lt;/code&gt;中一致，才能被检索到&lt;/p&gt;

&lt;h3 id=&quot;推送到官方库&quot;&gt;推送到官方库&lt;/h3&gt;
&lt;p&gt;最后是使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pod trunk&lt;/code&gt;命令，把podspec文件推送到CocoaPod官方库&lt;/p&gt;

&lt;p&gt;pod trunk 需要注册 具体做法这里不再赘述 请移步CocoaPod官网&lt;/p&gt;

&lt;p&gt;pod trunk 设置完毕后执行命令&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ pod trunk push AvidlyAdsSDK.podspec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因为我们依赖的SDK比较多，源码比较大，所以整个过程比较耗时。&lt;/p&gt;

&lt;p&gt;推送完成之后查询一下&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pod search AvidlyAdsSDK
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可以看到已经能查询到我们推送到CocoaPod官方的库了&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-&amp;gt; AvidlyAdsSDK (2.0.20)
   Avidly Ad SDK
   pod 'AvidlyAdsSDK', '~&amp;gt; 2.0.20'
   - Homepage: http://ads-sdk-doc.haloapps.com/docs/show/2
   - Source:   https://github.com/guojunliu/AvidlyAdsSDK.git
   - Versions: 2.0.20, 2.0.19 [AvidlyAdsSDK repo]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;search不到&quot;&gt;search不到？&lt;/h3&gt;

&lt;p&gt;上一步中，在推送到官方库之后，有可能在search的时候，search不到，出现下面的提示&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[!] Unable to find a pod with name, author, summary, or description matching `AvidlyAdsSDK`
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;虽然我们push到官方可了，但是依然search不到&lt;/p&gt;

&lt;p&gt;要解决这个问题，首先我们要了解下cocoapods的机制，在安装cocoapods的时候，使用过下面的命令&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pod setup
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这行命令其中最重要的作用就是将cocoapods官方repo，clone到我们本地。&lt;/p&gt;

&lt;p&gt;我们可以看下我们本地的repo&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pod repo list
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;master
- Type: git (master)
- URL:  https://github.com/CocoaPods/Specs.git
- Path: /Users/steve/.cocoapods/repos/master

1 repo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到我们本地目前只有一个repo，就是官方的master repo&lt;/p&gt;

&lt;p&gt;这个master repo中包含了所有push到cocoapod的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;podspec文件&lt;/code&gt;，可以去本机cocoapods目录下看一下，有成千上万的podspec文件。&lt;/p&gt;

&lt;p&gt;解决上述问题的最简单办法就是重新调用下&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pod setup&lt;/code&gt;，重新clone下master repo&lt;/p&gt;

&lt;h4 id=&quot;但是&quot;&gt;但是&lt;/h4&gt;

&lt;p&gt;由于master repo实在太大（大概700M+），我们不希望CP浪费时间在clone repo上，为了提高效率，所以我们要使用我们自己的私有repo&lt;/p&gt;

&lt;h3 id=&quot;私有库&quot;&gt;私有库&lt;/h3&gt;

&lt;p&gt;先来说一个概念，什么是repo？它是所有的Pods的一个索引，就是一个容器，所有公开的Pods都在这个里面，它实际是一个Git仓库remote端在GitHub上，但是当你使用了Cocoapods后它会被clone到本地的~/.cocoapods/repos目录下。可以进入到这个目录看到master文件夹就是这个官方的repo了。这个master目录的结构是这个样子的&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;master/xxx库/0.0.1版本/xxx.podspec
            /0.0.2版本/xxx.podspec
master/zzz库/2.0.1版本/zzz.podspec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;master&lt;/code&gt;是repo名称，下一级目录&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xxx库&lt;/code&gt;是你托管的库名称，再下一级&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0.0.1版本&lt;/code&gt;是你库的版本，再下一级&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xxx.podspec&lt;/code&gt;就是你自己的podspec&lt;/p&gt;

&lt;p&gt;所以我们模拟这个目录创建一个就好了&lt;/p&gt;

&lt;p&gt;首先创建一个git库，这里是&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://github.com/guojunliu/AvidlyAdsSDK-SpecsRepo.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接下来在创建目录及文件&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AvidlyAdsSDK/2.0.20/AvidlyAdsSDK.podspec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果需要维护多个版本的线上包，那就&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AvidlyAdsSDK/2.0.19/AvidlyAdsSDK.podspec
            /2.0.20/AvidlyAdsSDK.podspec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接下来push到github上&lt;/p&gt;

&lt;p&gt;repo创建完了，接下来我们将repo clone到我们本地，先看下我们本地的repo&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pod repo list
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;master
- Type: git (master)
- URL:  https://github.com/CocoaPods/Specs.git
- Path: /Users/steve/.cocoapods/repos/master

1 repo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;只有master&lt;/p&gt;

&lt;p&gt;接下来colen我们自己的repo&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pod repo add Avidly https://github.com/guojunliu/AvidlyAdsSDK-SpecsRepo.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Avidly&lt;/code&gt;是我们repo clone到本地的名字，自己命名&lt;/p&gt;

&lt;p&gt;完成之后再来看下本地的repo&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Avidly
- Type: git (master)
- URL:  https://github.com/guojunliu/AvidlyAdsSDK-SpecsRepo.git
- Path: /Users/steve/.cocoapods/repos/Avidly

master
- Type: git (master)
- URL:  https://github.com/CocoaPods/Specs.git
- Path: /Users/steve/.cocoapods/repos/master

2 repos
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;已经存在了，可以去~/.cocoapods/repos目录下瞅瞅&lt;/p&gt;

&lt;p&gt;接下来再search就可以找到我们托管的Framework了&lt;/p&gt;

&lt;p&gt;这样我们就不用让CP再等待setup了&lt;/p&gt;

&lt;h3 id=&quot;测试&quot;&gt;测试&lt;/h3&gt;

&lt;p&gt;Podfile如下&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;platform :ios, '8.0'
use_frameworks!

target ‘testAvidlyPod’ do
  source 'https://github.com/guojunliu/AvidlyAdsSDK-SpecsRepo.git'
  pod 'AvidlyAdsSDK', '~&amp;gt; 2.0.20'
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中source就是我们自己的私有库&lt;/p&gt;

&lt;h3 id=&quot;可能会遇到的问题&quot;&gt;可能会遇到的问题&lt;/h3&gt;

&lt;p&gt;1、swift验证不过&lt;/p&gt;

&lt;p&gt;2、xcode编译不过导致验证不过&lt;/p&gt;

&lt;p&gt;3、clone出错&lt;/p&gt;

&lt;p&gt;4、xcworkspace编译不过&lt;/p&gt;</content><author><name></name></author><category term="SDK" /><category term="Framework" /><summary type="html">在发布sdk中，需要在CocoaPods上托管Framework 安装CocoaPods 首先安装CocoaPods，没安装的自行安装 处理源码 第一步在github上创建源码库（我们的源码是Framework），并把源码push到github上 github地址： https://github.com/guojunliu/AvidlyAdsSDK.git podspec文件 第二步,在目录下创建.podspec文件，此处创建的是AvidlyAdsSDK.podspec， $ pod spec create AvidlyAdsSDK 用编辑器打开.podspec文件 (我自己用Sublime Text) 文件内容为 Pod::Spec.new do |s| s.name = 'AvidlyAdsSDK' s.version = '2.0.20' s.summary = 'Avidly Ad SDK' s.description = &amp;lt;&amp;lt;-DESC Avidly Ad SDK. DESC s.homepage = 'http://ads-sdk-doc.haloapps.com/docs/show/2' s.license = { :type =&amp;gt; 'MIT', :file =&amp;gt; 'LICENSE' } s.author = { &quot;steve&quot; =&amp;gt; &quot;steve.liu@holaverse.com&quot; } s.source = { :git =&amp;gt; 'https://github.com/guojunliu/AvidlyAdsSDK.git', :tag =&amp;gt; s.version } s.ios.deployment_target = '8.0' s.source_files = 'Framework/Appnext/include/*', 'Framework/Chance/include/*', 'Framework/Domob/include/*' s.resources = &quot;Framework/Chance/resource/*&quot;, &quot;Framework/Domob/resource/*&quot;, &quot;Framework/Vungle/resource/*&quot;, &quot;Framework/AvidlyAdsSDK/resource/*&quot;, s.public_header_files = 'Framework/Appnext/include/*', 'Framework/Chance/include/*', 'Framework/Domob/include/*' s.library = 'sqlite3', 'z' s.frameworks = 'QuartzCore', 'MediaPlayer', 'CoreMedia', 'CoreGraphics', 'CFNetwork', 'WebKit', 'WatchConnectivity', 'SystemConfiguration', 'StoreKit', 'Social', 'MessageUI','JavaScriptCore','EventKit','CoreTelephony','AVFoundation','AudioToolbox','AdSupport' s.vendored_libraries = &quot;Framework/Appnext/libAppnextLib.a&quot;, &quot;Framework/Appnext/libAppnextSDKCore.a&quot;, &quot;Framework/Chance/libChanceAd_Video.a&quot;, &quot;Framework/Domob/libIndependentVideoSDK.a&quot; s.vendored_frameworks = 'Framework/AdColony/AdColony.framework', 'Framework/Mobvista/MVSDK.framework', 'Framework/Mobvista/MVSDKReward.framework', 'Framework/Unity/UnityAds.framework', 'Framework/Vungle/VungleSDK.framework', 'Framework/AvidlyAdsSDK/AvidlyAdsSDK.framework', 'Framework/FBAudienceNetwork/FBAudienceNetwork.framework', 'Framework/GoogleMobileAds/GoogleMobileAds.framework', 'Framework/HolaStatisticalSDK/HolaStatisticalSDK.framework', 'Framework/OneWay/OneWaySDK.framework' end 字段解释 字段 解释</summary></entry><entry><title type="html">djinni中文文档</title><link href="http://localhost:4000/djinni/" rel="alternate" type="text/html" title="djinni中文文档" /><published>2016-10-28T00:00:00+08:00</published><updated>2016-10-28T00:00:00+08:00</updated><id>http://localhost:4000/djinni</id><content type="html" xml:base="http://localhost:4000/djinni/">&lt;p&gt;Djinni 是一个用来生成跨语言的类型声明和接口绑定的工具，主要用于 C++ 和 Java 以及 Objective-C 间的互通。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;好处：&lt;/li&gt;
  &lt;li&gt;用了接口描述文件。声明清晰、修改简易，并保证了跨平台接口的一致性。&lt;/li&gt;
  &lt;li&gt;自动生成接口绑定代码。免去了绑定 C++ 和 Java (JNI) 及 Objective-C (Objective-C++) 的麻烦。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1-配置djinni&quot;&gt;1 配置djinni&lt;/h2&gt;

&lt;h3 id=&quot;11-下载djinni&quot;&gt;1.1 下载djinni&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://github.com/dropbox/djinni.git 将下载好的djinni放在[example_root]/deps/ 下
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此时目录结构为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/djinni/1.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;12-编译djinni&quot;&gt;1.2 编译djinni&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd [djinni_root]/
$ src/build
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;../images/djinni/2.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第一次编译的时候会去下载sbt配置&lt;/p&gt;

&lt;p&gt;本人系统环境是macOS Sierra 10.12 , 在此环境下sbt下载失败，导致编译失败&lt;/p&gt;

&lt;p&gt;如果sbt下载失败的话，项目中放置了一个sbt的压缩包（里边文件默认隐藏的），复制里边的文件到你的用户文件夹下就可以了&lt;/p&gt;

&lt;h2 id=&quot;2-使用djinni&quot;&gt;2 使用djinni&lt;/h2&gt;

&lt;h3 id=&quot;21-编写djinni格式文件&quot;&gt;2.1 编写djinni格式文件&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hello_world = interface +c {
	static create():hello_world;
	get_hello_world(): string;
	get_name(): string;
	set_name(name:string);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;命名为helloworld.djinni 并放置在[example_root]/ 下&lt;/p&gt;

&lt;h3 id=&quot;22-编写shell文件&quot;&gt;2.2 编写shell文件&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#! /usr/bin/env bash
 
base_dir=$(cd &quot;`dirname &quot;0&quot;`&quot; &amp;amp;&amp;amp; pwd)
cpp_out=&quot;$base_dir/generated-src/cpp&quot;
jni_out=&quot;$base_dir/generated-src/jni&quot;
objc_out=&quot;$base_dir/generated-src/objc&quot;
java_out=&quot;$base_dir/generated-src/java/com/mycompany/helloworld&quot;
java_package=&quot;com.mycompany.helloworld&quot;
namespace=&quot;helloworld&quot;
objc_prefix=&quot;HW&quot;
djinni_file=&quot;helloworld.djinni&quot;
 
deps/djinni/src/run \
   		--java-out $java_out \
   		--java-package $java_package \
   		--ident-java-field mFooBar \
   		\
   		--cpp-out $cpp_out \
   		--cpp-namespace $namespace \
   		\
   		--jni-out $jni_out \
   		--ident-jni-class NativeFooBar \
   		--ident-jni-file NativeFooBar \
   		\
   		--objc-out $objc_out \
   		--objc-type-prefix $objc_prefix \
   		\
   		--objcpp-out $objc_out \
   		\
   		--idl $djinni_file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;命名为run_djinni.sh 并放置在[example_root]/ 下&lt;/p&gt;

&lt;p&gt;此时目录结构为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/djinni/3.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;23-生成接口代码&quot;&gt;2.3 生成接口代码&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd [example_root]/  
$ sh ./run_djinni.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;运行成功输出：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/djinni/4.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以及现在目录结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/djinni/5.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里可以看到：依据描述文件helloworld.djinni，在generated-src目录下自动生产了 C++ 和 Java 及 Objective-C 的绑定代码。继续要做的，只是写它们的具体实现&lt;/p&gt;

&lt;h2 id=&quot;3-编写c代码&quot;&gt;3 编写c++代码&lt;/h2&gt;
&lt;h3 id=&quot;31-创建c工程&quot;&gt;3.1 创建c++工程&lt;/h3&gt;
&lt;p&gt;这里用 XCode 创建一个 C++ 工程，来测试 C++ 接口代码。&lt;/p&gt;

&lt;p&gt;首先，打开 XCode ，选择”Create a new Xcode project”。然后，选择”Command Line Tool”，来新建命令行工具。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/djinni/6.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;“Next”到下一步时，”Language”选择”C++”。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/djinni/7.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;“Next”到下一步，放在[example_root]/ 下&lt;/p&gt;

&lt;p&gt;此时目录结构为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/djinni/8.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;32-编写c实现代码&quot;&gt;3.2 编写c++实现代码&lt;/h3&gt;

&lt;p&gt;首先在[example_root]/ 下创建src/cpp目录，用来存放c++实现代码&lt;/p&gt;

&lt;p&gt;src/cpp/hello_world_impl.hpp:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#pragma once
 
#include &quot;hello_world.hpp&quot;
 
namespace helloworld {

	class HelloWorldImpl : public helloworld::HelloWorld {
    
	public:
    
    	// Constructor
    	HelloWorldImpl();
    
    	// Our method that returns a string
    	std::string get_hello_world();
    
	};

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;src/cpp/hello_world_impl.cpp:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &quot;hello_world_impl.hpp&quot;
#include &amp;lt;string&amp;gt;
 
namespace helloworld {

	std::shared_ptr&amp;lt;HelloWorld&amp;gt; HelloWorld::create() {
	    return std::make_shared&amp;lt;HelloWorldImpl&amp;gt;();
	}
	
	HelloWorldImpl::HelloWorldImpl() {
 	
	}

	std::string HelloWorldImpl::get_hello_world() {
    
 	   std::string myString = &quot;Hello World! &quot;;
    
   	 time_t t = time(0);
   	 tm now=*localtime(&amp;amp;t);
    	char tmdescr[200]={0};
    	const char fmt[]=&quot;%r&quot;;
    	if (strftime(tmdescr, sizeof(tmdescr)-1, fmt, &amp;amp;now)&amp;gt;0) {
    	    myString += tmdescr;
    	}
    
    	return myString;
    
	}

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此时目录结构为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/djinni/9.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;33-调试c代码&quot;&gt;3.3 调试c++代码&lt;/h3&gt;

&lt;p&gt;接下来，把以下 C++ 接口代码文件，拖动到 Xcode 工程目录来引入(只需引用文件，避免复制。)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;generated-src/cpp/hello_world.hpp
src/cpp/hello_world_impl.cpp
src/cpp/hello_world_impl.hpp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此时目录结构为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/djinni/10.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;编写以下代码：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

#include &quot;hello_world_impl.hpp&quot;

int main(int argc, const char * argv[]) {

	helloworld::HelloWorldImpl hw = helloworld::HelloWorldImpl();

	string myString = hw.get_hello_world();
	cout &amp;lt;&amp;lt; myString &amp;lt;&amp;lt; endl;

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出为:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hello World! 02:28:10 PM
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;c++代码调试通过&lt;/p&gt;

&lt;h2 id=&quot;4-ios工程&quot;&gt;4 iOS工程&lt;/h2&gt;
&lt;h3 id=&quot;41-创建ios工程&quot;&gt;4.1 创建ios工程&lt;/h3&gt;

&lt;p&gt;在[example_root]/ 下创建ios_project目录&lt;/p&gt;

&lt;p&gt;Xcode创建ios工程，命名为HelloWorld&lt;/p&gt;

&lt;h3 id=&quot;42-添加文件&quot;&gt;4.2 添加文件&lt;/h3&gt;
&lt;p&gt;将以下目录中文件加入Xcode（只引用不copy），并虚拟目录分组为oc，c++，djinni&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[example_root]/generated-src/objc/
[example_root]/generated-src/cpp/
[example_root]/scr/cpp/
[example_root]/deps/djinni/support-lib/objc/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此时目录结构为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/djinni/11.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中&lt;/p&gt;

&lt;p&gt;oc文件夹中为djinni生成的接口文件
c++文件夹中为djinni生成的接口文件和我们自己写的c++实现文件
djinni文件夹中为转换文件（拖入工程就可以了）&lt;/p&gt;

&lt;h2 id=&quot;43-调试&quot;&gt;4.3 调试&lt;/h2&gt;

&lt;p&gt;此时我们调用c++写的实现代码，只需要调用我们oc文件夹中的接口文件啦&lt;/p&gt;

&lt;p&gt;首先引入头文件&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &quot;HWHelloWorld.h&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接着调用代码&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSString *str = [[HWHelloWorld create] getHelloWorld];
NSLog(@&quot;str:%@&quot;,str);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hello World! 02:28:10 PM
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;perfect ！！！&lt;/p&gt;

&lt;h2 id=&quot;问答&quot;&gt;问答&lt;/h2&gt;
&lt;p&gt;Q：oc可以和c++混编为objective-c++，那么我们直接oc和c++互相调用不就行了吗，为什么还要用djinni呢？&lt;/p&gt;

&lt;p&gt;A：oc可以和c++混编，但是java是需要通过jni。所以使用djinni就是为了统一接口，让同一份c++代码可以被oc和java调用，让c++工程师、objective-c工程师、java工程师能够愉快的一起合作项目。ps：如果只是单纯的想在oc里边混编c++，可以完全不用djinni&lt;/p&gt;

&lt;p&gt;Q：上边的例子中，是c++写实现代码，java和oc调用，那么有没有oc和java写实现代码，c++调用呢？&lt;/p&gt;

&lt;p&gt;A：提出这个问题，说明你对c++跨平台有一定的了解了。当然啦，有调用，就有被调用。如果仔细看的上边的例子的话，会发现我们在helloworld.djinni文件中定义接口的时候，我们是这样写的hello_world = interface +c {}，那么这个+c是什么意思的，+c就是c++来实现代码，供其他平台调用。反过来我们可以写 +j +o，意思就是java和oc写实现代码，c++来调用。这样就实现了c++，java，oc之间的互相调用&lt;/p&gt;

&lt;p&gt;Q：djinni与世面上的H5技术跨平台，Xamarin跨平台有什么区别呢？&lt;/p&gt;

&lt;p&gt;A：首先来回答djinni和h5、Xamarin的区别。djinni可以说是由下至上的跨平台，主要用底层逻辑代码的跨平台，而UI则交给iOS和android平台去完成。h5则是由上至下的跨平台，UI统一，底层逻辑需要iOS和android各自平台去实现。而Xamarin则可以说是上下齐发力，底层是c#翻译ios的cocoa Touch框架和android框架，UI用自创的的框架统一ios和android平台的UI。&lt;/p&gt;

&lt;p&gt;优缺点：&lt;/p&gt;

&lt;p&gt;djinni：优点是不依赖于IDE，更底层，速度更快，更稳定。缺点是得会c++。如果公司做游戏的，那么c++大神应该会不少（笔者就是这个情况）&lt;/p&gt;

&lt;p&gt;H5：前几年h5最大的问题，就是性能，渲染太差，这几年好了很多。缺点是很多底层API调用不到，需要各自平台去实现&lt;/p&gt;

&lt;p&gt;Xamarin：笔者有幸研究了大半年的Xamarin，翻译了已经上架的一个APP。优点是统一了语言c#。缺点是收费（现在已经免费了），依赖IDE，要用Xamarin Studio或者VS。对习惯了Xcode的coder可能比较难接受，另外一个缺点，就是ios和android已经有很多成熟的库，而xamarin没有。比如笔者要接一个支付宝支付，然而并没有这样的xamarin库，需要使用者自己去binding。&lt;/p&gt;

&lt;p&gt;最后，这个问题，选你适合的跨平台解决方案。&lt;/p&gt;

&lt;p&gt;问答会持续更新哦 ！！！&lt;/p&gt;

&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;

&lt;p&gt;一个根据djinni写成的demo（ios），解决了macOS Sierra下第一次build时出错的问题&lt;/p&gt;

&lt;p&gt;原文及demo托管在github上 https://github.com/guojunliu/djinni&lt;/p&gt;

&lt;p&gt;如果这篇文章或者demo能帮到你的话，麻烦给个Star，给个星星哦，能让它继续帮到想使用djinni的人&lt;/p&gt;</content><author><name></name></author><category term="c++" /><category term="djinni" /><summary type="html">Djinni 是一个用来生成跨语言的类型声明和接口绑定的工具，主要用于 C++ 和 Java 以及 Objective-C 间的互通。 好处： 用了接口描述文件。声明清晰、修改简易，并保证了跨平台接口的一致性。 自动生成接口绑定代码。免去了绑定 C++ 和 Java (JNI) 及 Objective-C (Objective-C++) 的麻烦。 1 配置djinni 1.1 下载djinni https://github.com/dropbox/djinni.git 将下载好的djinni放在[example_root]/deps/ 下 此时目录结构为： 1.2 编译djinni $ cd [djinni_root]/ $ src/build 第一次编译的时候会去下载sbt配置 本人系统环境是macOS Sierra 10.12 , 在此环境下sbt下载失败，导致编译失败 如果sbt下载失败的话，项目中放置了一个sbt的压缩包（里边文件默认隐藏的），复制里边的文件到你的用户文件夹下就可以了 2 使用djinni 2.1 编写djinni格式文件 hello_world = interface +c { static create():hello_world; get_hello_world(): string; get_name(): string; set_name(name:string); } 命名为helloworld.djinni 并放置在[example_root]/ 下 2.2 编写shell文件 #! /usr/bin/env bash base_dir=$(cd &quot;`dirname &quot;0&quot;`&quot; &amp;amp;&amp;amp; pwd) cpp_out=&quot;$base_dir/generated-src/cpp&quot; jni_out=&quot;$base_dir/generated-src/jni&quot; objc_out=&quot;$base_dir/generated-src/objc&quot; java_out=&quot;$base_dir/generated-src/java/com/mycompany/helloworld&quot; java_package=&quot;com.mycompany.helloworld&quot; namespace=&quot;helloworld&quot; objc_prefix=&quot;HW&quot; djinni_file=&quot;helloworld.djinni&quot; deps/djinni/src/run \ --java-out $java_out \ --java-package $java_package \ --ident-java-field mFooBar \ \ --cpp-out $cpp_out \ --cpp-namespace $namespace \ \ --jni-out $jni_out \ --ident-jni-class NativeFooBar \ --ident-jni-file NativeFooBar \ \ --objc-out $objc_out \ --objc-type-prefix $objc_prefix \ \ --objcpp-out $objc_out \ \ --idl $djinni_file 命名为run_djinni.sh 并放置在[example_root]/ 下 此时目录结构为： 2.3 生成接口代码 $ cd [example_root]/ $ sh ./run_djinni.sh 运行成功输出： 以及现在目录结构： 这里可以看到：依据描述文件helloworld.djinni，在generated-src目录下自动生产了 C++ 和 Java 及 Objective-C 的绑定代码。继续要做的，只是写它们的具体实现 3 编写c++代码 3.1 创建c++工程 这里用 XCode 创建一个 C++ 工程，来测试 C++ 接口代码。 首先，打开 XCode ，选择”Create a new Xcode project”。然后，选择”Command Line Tool”，来新建命令行工具。 “Next”到下一步时，”Language”选择”C++”。 “Next”到下一步，放在[example_root]/ 下 此时目录结构为： 3.2 编写c++实现代码 首先在[example_root]/ 下创建src/cpp目录，用来存放c++实现代码 src/cpp/hello_world_impl.hpp: #pragma once #include &quot;hello_world.hpp&quot; namespace helloworld { class HelloWorldImpl : public helloworld::HelloWorld { public: // Constructor HelloWorldImpl(); // Our method that returns a string std::string get_hello_world(); }; } src/cpp/hello_world_impl.cpp: #include &quot;hello_world_impl.hpp&quot; #include &amp;lt;string&amp;gt; namespace helloworld { std::shared_ptr&amp;lt;HelloWorld&amp;gt; HelloWorld::create() { return std::make_shared&amp;lt;HelloWorldImpl&amp;gt;(); } HelloWorldImpl::HelloWorldImpl() { } std::string HelloWorldImpl::get_hello_world() { std::string myString = &quot;Hello World! &quot;; time_t t = time(0); tm now=*localtime(&amp;amp;t); char tmdescr[200]={0}; const char fmt[]=&quot;%r&quot;; if (strftime(tmdescr, sizeof(tmdescr)-1, fmt, &amp;amp;now)&amp;gt;0) { myString += tmdescr; } return myString; } } 此时目录结构为： 3.3 调试c++代码 接下来，把以下 C++ 接口代码文件，拖动到 Xcode 工程目录来引入(只需引用文件，避免复制。) generated-src/cpp/hello_world.hpp src/cpp/hello_world_impl.cpp src/cpp/hello_world_impl.hpp 此时目录结构为： 编写以下代码： #include &amp;lt;iostream&amp;gt; using namespace std; #include &quot;hello_world_impl.hpp&quot; int main(int argc, const char * argv[]) { helloworld::HelloWorldImpl hw = helloworld::HelloWorldImpl(); string myString = hw.get_hello_world(); cout &amp;lt;&amp;lt; myString &amp;lt;&amp;lt; endl; return 0; } 输出为: Hello World! 02:28:10 PM c++代码调试通过 4 iOS工程 4.1 创建ios工程 在[example_root]/ 下创建ios_project目录 Xcode创建ios工程，命名为HelloWorld 4.2 添加文件 将以下目录中文件加入Xcode（只引用不copy），并虚拟目录分组为oc，c++，djinni [example_root]/generated-src/objc/ [example_root]/generated-src/cpp/ [example_root]/scr/cpp/ [example_root]/deps/djinni/support-lib/objc/ 此时目录结构为： 其中 oc文件夹中为djinni生成的接口文件 c++文件夹中为djinni生成的接口文件和我们自己写的c++实现文件 djinni文件夹中为转换文件（拖入工程就可以了） 4.3 调试 此时我们调用c++写的实现代码，只需要调用我们oc文件夹中的接口文件啦 首先引入头文件 #import &quot;HWHelloWorld.h&quot; 接着调用代码 NSString *str = [[HWHelloWorld create] getHelloWorld]; NSLog(@&quot;str:%@&quot;,str); 输出 Hello World! 02:28:10 PM perfect ！！！ 问答 Q：oc可以和c++混编为objective-c++，那么我们直接oc和c++互相调用不就行了吗，为什么还要用djinni呢？ A：oc可以和c++混编，但是java是需要通过jni。所以使用djinni就是为了统一接口，让同一份c++代码可以被oc和java调用，让c++工程师、objective-c工程师、java工程师能够愉快的一起合作项目。ps：如果只是单纯的想在oc里边混编c++，可以完全不用djinni Q：上边的例子中，是c++写实现代码，java和oc调用，那么有没有oc和java写实现代码，c++调用呢？ A：提出这个问题，说明你对c++跨平台有一定的了解了。当然啦，有调用，就有被调用。如果仔细看的上边的例子的话，会发现我们在helloworld.djinni文件中定义接口的时候，我们是这样写的hello_world = interface +c {}，那么这个+c是什么意思的，+c就是c++来实现代码，供其他平台调用。反过来我们可以写 +j +o，意思就是java和oc写实现代码，c++来调用。这样就实现了c++，java，oc之间的互相调用 Q：djinni与世面上的H5技术跨平台，Xamarin跨平台有什么区别呢？ A：首先来回答djinni和h5、Xamarin的区别。djinni可以说是由下至上的跨平台，主要用底层逻辑代码的跨平台，而UI则交给iOS和android平台去完成。h5则是由上至下的跨平台，UI统一，底层逻辑需要iOS和android各自平台去实现。而Xamarin则可以说是上下齐发力，底层是c#翻译ios的cocoa Touch框架和android框架，UI用自创的的框架统一ios和android平台的UI。 优缺点： djinni：优点是不依赖于IDE，更底层，速度更快，更稳定。缺点是得会c++。如果公司做游戏的，那么c++大神应该会不少（笔者就是这个情况） H5：前几年h5最大的问题，就是性能，渲染太差，这几年好了很多。缺点是很多底层API调用不到，需要各自平台去实现 Xamarin：笔者有幸研究了大半年的Xamarin，翻译了已经上架的一个APP。优点是统一了语言c#。缺点是收费（现在已经免费了），依赖IDE，要用Xamarin Studio或者VS。对习惯了Xcode的coder可能比较难接受，另外一个缺点，就是ios和android已经有很多成熟的库，而xamarin没有。比如笔者要接一个支付宝支付，然而并没有这样的xamarin库，需要使用者自己去binding。 最后，这个问题，选你适合的跨平台解决方案。 问答会持续更新哦 ！！！ 最后 一个根据djinni写成的demo（ios），解决了macOS Sierra下第一次build时出错的问题 原文及demo托管在github上 https://github.com/guojunliu/djinni 如果这篇文章或者demo能帮到你的话，麻烦给个Star，给个星星哦，能让它继续帮到想使用djinni的人</summary></entry><entry><title type="html">iOS 10后的设备唯一标识替代方案 — XYUUID库</title><link href="http://localhost:4000/XYUUID/" rel="alternate" type="text/html" title="iOS 10后的设备唯一标识替代方案 — XYUUID库" /><published>2016-10-12T00:00:00+08:00</published><updated>2016-10-12T00:00:00+08:00</updated><id>http://localhost:4000/XYUUID</id><content type="html" xml:base="http://localhost:4000/XYUUID/">&lt;p&gt;iOS 10以后Apple对IDFA的获取逻辑进行了更新&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;iOS10以前，君子协议，不管用户是否同意使用IDFA，都可以获取到IDFA&lt;/li&gt;
  &lt;li&gt;iOS10以后，一旦开启了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;设置-&amp;gt;隐私-&amp;gt;广告-&amp;gt;限制广告跟踪&lt;/code&gt;之后 获取到的idfa将会是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;00000000-0000-0000-0000-000000000000&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;隐私一直是Apple的重中之重，从UDID，到MAC地址，再到IDFA，Apple在一步一步保护用户的隐私，但是也给开发者带来了不小的麻烦。在实际研发中，很多功能都要依赖于用户画像，而用户画像要依赖于设备唯一标识。&lt;/p&gt;

&lt;p&gt;在用户限制广告跟踪之后，依旧要寻找IDFA的替代品&lt;/p&gt;

&lt;h2 id=&quot;模拟设备唯一标识&quot;&gt;模拟设备唯一标识&lt;/h2&gt;

&lt;p&gt;在现行的环境中，要模拟设备唯一标识，需要考虑以下几个方面&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;较长的时效性&lt;/li&gt;
  &lt;li&gt;较长的存储性&lt;/li&gt;
  &lt;li&gt;较低的冲突率&lt;/li&gt;
  &lt;li&gt;较低的漂移率&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;一较长的时效性&quot;&gt;一、较长的时效性&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/youmi/SimulateIDFA/wiki/%E4%B8%AD%E6%96%87%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3&quot;&gt;SimulateIDFA&lt;/a&gt;是一个开源的根据设备信息生成UUID的库&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;生成原理&lt;/p&gt;

  &lt;p&gt;生成的MD5值分两部分。&lt;/p&gt;

  &lt;p&gt;以 626363D0-90D4-06BF-C281-384E4E69D3E2 为例：&lt;/p&gt;

  &lt;p&gt;前16位626363D0-90D4-06BF是由比较稳定的参数组合获得,这前16位只有在系统升级的情况下才会变。&lt;/p&gt;

  &lt;p&gt;后16位C281-384E4E69D3E2 由 一些比较容易被改变的参数组合生成，比较常见的值变化情况是系统重新启动。&lt;/p&gt;

  &lt;p&gt;参与前16位计算的参数有：&lt;/p&gt;

  &lt;p&gt;系统版本（9.3.2）、硬件信息（N53AP,iPhone6,2,中国移动46002,1048576000）、coreServices文件创建更新时间(2015-08-07 23:53:00 +0000,2016-06-07 23:53:09 +0000),系统容量(12266725376)&lt;/p&gt;

  &lt;p&gt;这里有一些信息是升级的时候会变的，系统版本、coreServices文件创建更新时间、系统容量&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;参与后16位计算的参数有：&lt;/p&gt;

  &lt;p&gt;系统开机时间(1473301191去掉后面的4位数 147330)、国家代码(CN)、本地语言(zh-Hans-CN)、设备名称(XXXX)
这里的参数都是比较容易变化的，系统重启离上次重启有10000秒的话会变，其他参数在设置里面可以修改&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;二较长的存储性&quot;&gt;二、较长的存储性&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KeyChain&lt;/code&gt;存储在iOS系统中,并且恢复iPhone会使keychain的内容也恢复。但是删除App是不会影响keychain.
不同App之间Keychain是不能相互访问的，但是可以通过配置keychain-sharing来解决。&lt;/p&gt;

&lt;h3 id=&quot;三较低的冲突率&quot;&gt;三、较低的冲突率&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/youmi/SimulateIDFA/wiki/%E4%B8%AD%E6%96%87%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3&quot;&gt;SimulateIDFA&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;

  &lt;p&gt;生成的ID重复的概率对比
假设一个情况。一天内某个国家有10000000（1千万）台相同型号的设备升级到同一个系统。&lt;/p&gt;

  &lt;p&gt;一天内这个算法可能的值计算， 24x3600（文件创建时间，单位秒）x 10（文件最后修改时间假设误差在10秒）x 10000000（系统容&amp;gt;量误差范围）x 9000000(设备名称范围，这里假设的是每10台就有2个重复,名称范围就是 10000000x0.9)= 77760000000000000000。&lt;/p&gt;

  &lt;p&gt;设备a的值为 K，那么设备b的值同为K的可能性为： 1/77760000000000000000. 总共有 10000000台设备。因此，这10000000设备中有与a设备的值同为K的可能性为 1/77760000000000000000 x 10000000 = 1/7776000000000。&lt;/p&gt;

  &lt;p&gt;iOS10.2 发布后 System/Library/CoreServices 文件夹的创建时间不能获取了。 这样最后算出来的与a可能有值相同的概率是 1/7776000000000 x 24 x 3600 = 1/90000000; ）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;四较低的漂移率&quot;&gt;四、较低的漂移率&lt;/h3&gt;

&lt;p&gt;较低的漂移率意味着在同一设备中不同App能获取到相同的值&lt;/p&gt;

&lt;h2 id=&quot;最后的解决方案&quot;&gt;最后的解决方案&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SimulateIDFA&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IDFA&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KeyChain&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SimulateIDFA&lt;/code&gt; 能提供&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;较长的时效性&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;较低的冲突率&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KeyChain&lt;/code&gt; 能提供较长的存储性&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SimulateIDFA + KeyChain&lt;/code&gt; 能有效的降低漂移率&lt;/li&gt;
  &lt;li&gt;在第一次能获取到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IDFA&lt;/code&gt;的情况下，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IDFA + KeyChain&lt;/code&gt;可以有效防止用户限制广告跟踪之后IDFA的变化&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;流程如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/YXUUID/1.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;核心代码如下&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (NSString *)uuidForDevice {
    NSString *deviceUUID = [XYKeyChain getDataWithServiceDomain:STR_XYUUIDForKeyChainAndDeviceOrIdfa];
    if (deviceUUID &amp;amp;&amp;amp; ![deviceUUID isEqualToString:@&quot;&quot;] &amp;amp;&amp;amp; ![deviceUUID isEqualToString:XY_ZeroIdfa]) {
        return deviceUUID;
    }
    
    NSString *idfa = [self uuidForIDFA];
    if (idfa &amp;amp;&amp;amp; ![idfa isEqualToString:@&quot;&quot;] &amp;amp;&amp;amp; ![idfa isEqualToString:XY_ZeroIdfa]) {
        [XYKeyChain setData:idfa serviceDomain:STR_XYUUIDForKeyChainAndDeviceOrIdfa];
        return idfa;
    }
    
    NSString *deviceInfoUUID = [self uuidForDeviceInfo];
    if (deviceInfoUUID &amp;amp;&amp;amp; ![deviceInfoUUID isEqualToString:@&quot;&quot;]) {
        [XYKeyChain setData:deviceInfoUUID serviceDomain:STR_XYUUIDForKeyChainAndDeviceOrIdfa];
        return deviceInfoUUID;
    }
    
    NSString *uuid = [self uuid];
    if (uuid &amp;amp;&amp;amp; ![uuid isEqualToString:@&quot;&quot;]) {
        [XYKeyChain setData:uuid serviceDomain:STR_XYUUIDForKeyChainAndDeviceOrIdfa];
        return uuid;
    }
    
    return @&quot;&quot;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;根据以上组合封装之后即为&lt;a href=&quot;https://github.com/guojunliu/XYUUID&quot;&gt;YXUUID&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;xyuuid介绍&quot;&gt;XYUUID介绍&lt;/h2&gt;

&lt;h3 id=&quot;xyuuid的优点&quot;&gt;XYUUID的优点&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;API简单&lt;/li&gt;
  &lt;li&gt;使用了最新的iOS 14 API来获取IDFA&lt;/li&gt;
  &lt;li&gt;具有不同持久性级别的通用唯一标识符&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;uuidfordevice的有点&quot;&gt;uuidForDevice的有点&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;较长的时效性&lt;/li&gt;
  &lt;li&gt;较长的存储性&lt;/li&gt;
  &lt;li&gt;较低的冲突率&lt;/li&gt;
  &lt;li&gt;较低的漂移率&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;api&quot;&gt;API&lt;/h3&gt;

&lt;p&gt;获取不同持久化级别的UUID&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/// 随机UUID，此值每次都会刷新
+ (NSString *)uuid;

/// 安装UUID，每次重新安装，此值会刷新
+ (NSString *)uuidForInstall;

/// 开启应用UUID，每次开启应用，此值会刷新
+ (NSString *)uuidForAppOpen;

/// IDFA，开启关闭授权，此值会刷新
+ (NSString *)uuidForIDFA;

/// IDFV
+ (NSString *)uuidForIDFV;

/// 设备信息UUID，根据设备信息生成，能维持一段时间内不变
+ (NSString *)uuidForDeviceInfo;

/// 钥匙串UUID，卸载应用保持不变
+ (NSString *)uuidForKeychain;

/// 设备UUID，设备唯一标识符
+ (NSString *)uuidForDevice;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;持久化级别&quot;&gt;持久化级别&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;UUID&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;App relaunch&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Reset Advertising Identifier&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;App reinstall&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;System reboot&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;System upgrade&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;System reset&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;uuid &lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;❌&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;❌&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;❌&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;❌&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;❌&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;❌&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;uuidForInstall &lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;✅&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;✅&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;❌&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;✅&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;✅&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;❌&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;uuidForAppOpen &lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;❌&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;✅&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;❌&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;❌&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;❌&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;❌&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;uuidForIDFA &lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;✅&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;❌&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;✅&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;✅&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;✅&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;❌&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;uuidForIDFV &lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;✅&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;✅&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;❌&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;✅&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;✅&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;❌&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;uuidForDeviceInfo &lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;✅&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;✅&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;✅&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;❌&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;❌&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;❌&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;uuidForKeychain &lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;✅&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;✅&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;✅&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;✅&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;✅&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;❌&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;uuidForDevice &lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;✅&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;✅&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;✅&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;✅&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;✅&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;❌&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><category term="idfa" /><category term="udid" /><summary type="html">iOS 10以后Apple对IDFA的获取逻辑进行了更新 iOS10以前，君子协议，不管用户是否同意使用IDFA，都可以获取到IDFA iOS10以后，一旦开启了设置-&amp;gt;隐私-&amp;gt;广告-&amp;gt;限制广告跟踪之后 获取到的idfa将会是00000000-0000-0000-0000-000000000000 隐私一直是Apple的重中之重，从UDID，到MAC地址，再到IDFA，Apple在一步一步保护用户的隐私，但是也给开发者带来了不小的麻烦。在实际研发中，很多功能都要依赖于用户画像，而用户画像要依赖于设备唯一标识。 在用户限制广告跟踪之后，依旧要寻找IDFA的替代品 模拟设备唯一标识 在现行的环境中，要模拟设备唯一标识，需要考虑以下几个方面 较长的时效性 较长的存储性 较低的冲突率 较低的漂移率 一、较长的时效性 SimulateIDFA是一个开源的根据设备信息生成UUID的库 生成原理 生成的MD5值分两部分。 以 626363D0-90D4-06BF-C281-384E4E69D3E2 为例： 前16位626363D0-90D4-06BF是由比较稳定的参数组合获得,这前16位只有在系统升级的情况下才会变。 后16位C281-384E4E69D3E2 由 一些比较容易被改变的参数组合生成，比较常见的值变化情况是系统重新启动。 参与前16位计算的参数有： 系统版本（9.3.2）、硬件信息（N53AP,iPhone6,2,中国移动46002,1048576000）、coreServices文件创建更新时间(2015-08-07 23:53:00 +0000,2016-06-07 23:53:09 +0000),系统容量(12266725376) 这里有一些信息是升级的时候会变的，系统版本、coreServices文件创建更新时间、系统容量 参与后16位计算的参数有： 系统开机时间(1473301191去掉后面的4位数 147330)、国家代码(CN)、本地语言(zh-Hans-CN)、设备名称(XXXX) 这里的参数都是比较容易变化的，系统重启离上次重启有10000秒的话会变，其他参数在设置里面可以修改 二、较长的存储性 KeyChain存储在iOS系统中,并且恢复iPhone会使keychain的内容也恢复。但是删除App是不会影响keychain. 不同App之间Keychain是不能相互访问的，但是可以通过配置keychain-sharing来解决。 三、较低的冲突率 SimulateIDFA 生成的ID重复的概率对比 假设一个情况。一天内某个国家有10000000（1千万）台相同型号的设备升级到同一个系统。 一天内这个算法可能的值计算， 24x3600（文件创建时间，单位秒）x 10（文件最后修改时间假设误差在10秒）x 10000000（系统容&amp;gt;量误差范围）x 9000000(设备名称范围，这里假设的是每10台就有2个重复,名称范围就是 10000000x0.9)= 77760000000000000000。 设备a的值为 K，那么设备b的值同为K的可能性为： 1/77760000000000000000. 总共有 10000000台设备。因此，这10000000设备中有与a设备的值同为K的可能性为 1/77760000000000000000 x 10000000 = 1/7776000000000。 iOS10.2 发布后 System/Library/CoreServices 文件夹的创建时间不能获取了。 这样最后算出来的与a可能有值相同的概率是 1/7776000000000 x 24 x 3600 = 1/90000000; ） 四、较低的漂移率 较低的漂移率意味着在同一设备中不同App能获取到相同的值 最后的解决方案 SimulateIDFA + IDFA + KeyChain SimulateIDFA 能提供较长的时效性和较低的冲突率 KeyChain 能提供较长的存储性 SimulateIDFA + KeyChain 能有效的降低漂移率 在第一次能获取到IDFA的情况下，IDFA + KeyChain可以有效防止用户限制广告跟踪之后IDFA的变化 流程如下 核心代码如下 + (NSString *)uuidForDevice { NSString *deviceUUID = [XYKeyChain getDataWithServiceDomain:STR_XYUUIDForKeyChainAndDeviceOrIdfa]; if (deviceUUID &amp;amp;&amp;amp; ![deviceUUID isEqualToString:@&quot;&quot;] &amp;amp;&amp;amp; ![deviceUUID isEqualToString:XY_ZeroIdfa]) { return deviceUUID; } NSString *idfa = [self uuidForIDFA]; if (idfa &amp;amp;&amp;amp; ![idfa isEqualToString:@&quot;&quot;] &amp;amp;&amp;amp; ![idfa isEqualToString:XY_ZeroIdfa]) { [XYKeyChain setData:idfa serviceDomain:STR_XYUUIDForKeyChainAndDeviceOrIdfa]; return idfa; } NSString *deviceInfoUUID = [self uuidForDeviceInfo]; if (deviceInfoUUID &amp;amp;&amp;amp; ![deviceInfoUUID isEqualToString:@&quot;&quot;]) { [XYKeyChain setData:deviceInfoUUID serviceDomain:STR_XYUUIDForKeyChainAndDeviceOrIdfa]; return deviceInfoUUID; } NSString *uuid = [self uuid]; if (uuid &amp;amp;&amp;amp; ![uuid isEqualToString:@&quot;&quot;]) { [XYKeyChain setData:uuid serviceDomain:STR_XYUUIDForKeyChainAndDeviceOrIdfa]; return uuid; } return @&quot;&quot;; } 根据以上组合封装之后即为YXUUID XYUUID介绍 XYUUID的优点 API简单 使用了最新的iOS 14 API来获取IDFA 具有不同持久性级别的通用唯一标识符 uuidForDevice的有点 较长的时效性 较长的存储性 较低的冲突率 较低的漂移率 API 获取不同持久化级别的UUID /// 随机UUID，此值每次都会刷新 + (NSString *)uuid; /// 安装UUID，每次重新安装，此值会刷新 + (NSString *)uuidForInstall; /// 开启应用UUID，每次开启应用，此值会刷新 + (NSString *)uuidForAppOpen; /// IDFA，开启关闭授权，此值会刷新 + (NSString *)uuidForIDFA; /// IDFV + (NSString *)uuidForIDFV; /// 设备信息UUID，根据设备信息生成，能维持一段时间内不变 + (NSString *)uuidForDeviceInfo; /// 钥匙串UUID，卸载应用保持不变 + (NSString *)uuidForKeychain; /// 设备UUID，设备唯一标识符 + (NSString *)uuidForDevice; 持久化级别 UUID App relaunch Reset Advertising Identifier App reinstall System reboot System upgrade System reset              </summary></entry></feed>